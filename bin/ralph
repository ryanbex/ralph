#!/usr/bin/env bash
set -euo pipefail

# Ralph - Global Multi-Repo Autonomous Development Orchestrator
# Version 2.0 - Global installation with project registry

RALPH_HOME="${RALPH_HOME:-$HOME/.ralph}"
RALPH_VERSION="2.0.0"

# Colors (using $'...' for proper escape interpretation)
RED=$'\033[0;31m'
GREEN=$'\033[0;32m'
YELLOW=$'\033[1;33m'
BLUE=$'\033[0;34m'
CYAN=$'\033[0;36m'
BOLD=$'\033[1m'
DIM=$'\033[2m'
NC=$'\033[0m'

# Box drawing characters
H_LINE="─"
V_LINE="│"
TL_CORNER="┌"
TR_CORNER="┐"
BL_CORNER="└"
BR_CORNER="┘"
T_RIGHT="├"
T_LEFT="┤"

#═══════════════════════════════════════════════════════════════
# Utility Functions
#═══════════════════════════════════════════════════════════════

log() { echo -e "${GREEN}[Ralph]${NC} $1"; }
warn() { echo -e "${YELLOW}[Ralph]${NC} $1"; }
error() { echo -e "${RED}[Ralph]${NC} $1"; }

# Send Bark push notification
notify() {
    local title="$1"
    local message="$2"

    if [[ -f "$RALPH_HOME/config.yaml" ]]; then
        local bark_url
        bark_url=$(grep -A2 "bark:" "$RALPH_HOME/config.yaml" 2>/dev/null | grep "url:" | sed 's/.*url: *"//' | sed 's/".*//' || true)

        if [[ -n "$bark_url" ]]; then
            # URL encode the message
            local encoded
            encoded=$(printf '%s' "$message" | jq -sRr @uri 2>/dev/null || echo "$message")
            curl -s "${bark_url}/${title}/${encoded}" > /dev/null 2>&1 &
        fi
    fi
}

# Archive workstream metrics before cleanup
archive_workstream() {
    local project="$1"
    local workstream="$2"
    local final_status="$3"

    local state_dir="$RALPH_HOME/state/${project}/${workstream}"
    local metrics_file="${state_dir}/metrics.json"
    local history_file="$RALPH_HOME/archive/history.json"

    if [[ -f "$metrics_file" ]]; then
        mkdir -p "$RALPH_HOME/archive"

        # Build record with project/workstream/status/end_time
        local record
        record=$(jq -c --arg p "$project" --arg w "$workstream" \
                      --arg s "$final_status" \
                      --arg et "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                      '. + {project: $p, workstream: $w, status: $s, end_time: $et}' \
                      "$metrics_file" 2>/dev/null)

        if [[ -n "$record" ]]; then
            echo "$record" >> "$history_file"
            log "Archived metrics for ${project}/${workstream}"
        fi
    fi
}

# Calculate duration between two ISO timestamps
format_duration_between() {
    local start_time="$1"
    local end_time="$2"

    if [[ -z "$start_time" || -z "$end_time" || "$start_time" == "null" || "$end_time" == "null" ]]; then
        echo "-"
        return
    fi

    local start_sec end_sec diff
    start_sec=$(date -j -f "%Y-%m-%dT%H:%M:%SZ" "$start_time" +%s 2>/dev/null || echo 0)
    end_sec=$(date -j -f "%Y-%m-%dT%H:%M:%SZ" "$end_time" +%s 2>/dev/null || echo 0)
    diff=$((end_sec - start_sec))

    if [[ $diff -lt 0 || $start_sec -eq 0 || $end_sec -eq 0 ]]; then
        echo "-"
        return
    fi

    if [[ $diff -ge 3600 ]]; then
        printf "%dh %dm" $((diff/3600)) $(((diff%3600)/60))
    elif [[ $diff -ge 60 ]]; then
        printf "%dm" $((diff/60))
    else
        printf "%ds" $diff
    fi
}

# Parse YAML value (simple)
yaml_get() {
    local file="$1"
    local key="$2"
    grep "^${key}:" "$file" 2>/dev/null | sed "s/^${key}: *//" | sed 's/^ *//' | sed 's/ *$//'
}

#═══════════════════════════════════════════════════════════════
# Project Detection & Registry
#═══════════════════════════════════════════════════════════════

# Detect project from current directory
detect_project() {
    local cwd
    cwd=$(pwd)

    # Check all registered projects
    for project_file in "$RALPH_HOME/projects/"*.yaml; do
        [[ -f "$project_file" ]] || continue

        local root
        root=$(yaml_get "$project_file" "root")

        # Check if cwd is within project root
        if [[ "$cwd" == "$root"* ]]; then
            basename "$project_file" .yaml
            return 0
        fi
    done

    # Fallback: check if we're in a git repo
    if git rev-parse --git-dir &>/dev/null; then
        local git_root
        git_root=$(git rev-parse --show-toplevel)
        basename "$git_root"
        return 0
    fi

    echo ""
    return 1
}

# Get project config file path
get_project_file() {
    local project="$1"
    echo "$RALPH_HOME/projects/${project}.yaml"
}

# Check if project exists
project_exists() {
    local project="$1"
    [[ -f "$(get_project_file "$project")" ]]
}

# Get project root directory
get_project_root() {
    local project="$1"
    local project_file
    project_file=$(get_project_file "$project")
    yaml_get "$project_file" "root"
}

# Get project type (single-repo or multi-repo)
get_project_type() {
    local project="$1"
    local project_file
    project_file=$(get_project_file "$project")
    yaml_get "$project_file" "type"
}

# Get list of repos for multi-repo project
get_project_repos() {
    local project="$1"
    local project_file
    project_file=$(get_project_file "$project")

    if [[ "$(get_project_type "$project")" == "multi-repo" ]]; then
        grep -A1000 "^repos:" "$project_file" 2>/dev/null | grep "path:" | sed 's/.*path: *//' | tr -d '"' || true
    fi
}

#═══════════════════════════════════════════════════════════════
# Workstream Functions
#═══════════════════════════════════════════════════════════════

# Get workstream config directory
get_workstream_dir() {
    local project="$1"
    local workstream="$2"
    echo "$RALPH_HOME/workstreams/${project}/${workstream}"
}

# Get workstream state directory
get_state_dir() {
    local project="$1"
    local workstream="$2"
    echo "$RALPH_HOME/state/${project}/${workstream}"
}

# Get workstream log directory
get_log_dir() {
    local project="$1"
    local workstream="$2"
    echo "$RALPH_HOME/logs/${project}/${workstream}"
}

# Get worktree path for a workstream
get_worktree_path() {
    local project="$1"
    local workstream="$2"
    local project_root
    project_root=$(get_project_root "$project")
    echo "${project_root}-${workstream}"
}

# Get tmux session name
get_session_name() {
    local project="$1"
    local workstream="$2"
    echo "ralph-${project}-${workstream}"
}

# Get all workstreams for a project (from state directory)
get_workstreams() {
    local project="$1"
    local state_base="$RALPH_HOME/state/${project}"

    # Check state directory for workstreams
    if [[ -d "$state_base" ]]; then
        for ws_dir in "$state_base"/*/; do
            if [[ -d "$ws_dir" ]]; then
                basename "$ws_dir"
            fi
        done
    fi
}

# Get workstream status
get_status() {
    local project="$1"
    local workstream="$2"
    local state_dir
    state_dir=$(get_state_dir "$project" "$workstream")
    local session
    session=$(get_session_name "$project" "$workstream")

    if [[ -f "${state_dir}/question" ]]; then
        echo "NEEDS_INPUT"
    elif tmux has-session -t "$session" 2>/dev/null; then
        if [[ -f "${state_dir}/status" ]]; then
            cat "${state_dir}/status"
        else
            echo "RUNNING"
        fi
    else
        echo "STOPPED"
    fi
}

# Get current iteration
get_iteration() {
    local project="$1"
    local workstream="$2"
    local state_dir
    state_dir=$(get_state_dir "$project" "$workstream")

    if [[ -f "${state_dir}/iteration" ]]; then
        cat "${state_dir}/iteration"
    else
        echo "0"
    fi
}

# Get pending question
get_question() {
    local project="$1"
    local workstream="$2"
    local state_dir
    state_dir=$(get_state_dir "$project" "$workstream")

    if [[ -f "${state_dir}/question" ]]; then
        cat "${state_dir}/question"
    fi
}

# Get metrics for a workstream
get_metrics() {
    local project="$1"
    local workstream="$2"
    local state_dir
    state_dir=$(get_state_dir "$project" "$workstream")
    local metrics_file="${state_dir}/metrics.json"

    if [[ -f "$metrics_file" ]]; then
        cat "$metrics_file"
    else
        echo '{"tokens_in":0,"tokens_out":0,"total_cost":0,"start_time":"","max_iterations":0,"iterations_completed":0}'
    fi
}

# Get note for a workstream
get_note() {
    local project="$1"
    local workstream="$2"
    local state_dir
    state_dir=$(get_state_dir "$project" "$workstream")
    local note_file="${state_dir}/note"

    if [[ -f "$note_file" ]]; then
        cat "$note_file"
    fi
}

# Detect issues with a workstream that need attention
# Returns: issue type and description as "TYPE|description"
detect_workstream_issues() {
    local project="$1"
    local workstream="$2"
    local state_dir
    state_dir=$(get_state_dir "$project" "$workstream")
    local session
    session=$(get_session_name "$project" "$workstream")

    local status iteration metrics max_iter
    status=$(get_status "$project" "$workstream")
    iteration=$(get_iteration "$project" "$workstream")
    metrics=$(get_metrics "$project" "$workstream")
    max_iter=$(echo "$metrics" | jq -r '.max_iterations // 100')

    # Check for various issue conditions
    case "$status" in
        NEEDS_INPUT)
            local question
            question=$(get_question "$project" "$workstream")
            echo "NEEDS_INPUT|Waiting for answer: ${question:0:80}"
            return 0
            ;;
        ERROR)
            echo "ERROR|Claude Code exited with error"
            return 0
            ;;
        STUCK)
            echo "STUCK|No progress for multiple iterations"
            return 0
            ;;
        COMPLETE)
            echo "COMPLETE|Ready for cleanup"
            return 0
            ;;
        STOPPED)
            # Check if stopped at max iterations without completing
            if [[ $iteration -ge $max_iter ]] && [[ $max_iter -gt 0 ]]; then
                echo "MAX_ITER|Reached max iterations ($iteration/$max_iter) without completing"
                return 0
            fi
            ;;
        RUNNING)
            # Check if tmux session actually exists
            if ! tmux has-session -t "$session" 2>/dev/null; then
                echo "ORPHANED|Session crashed - state is stale"
                return 0
            fi
            ;;
    esac

    # No issues
    return 1
}

# Get last meaningful progress from logs or PROGRESS.md
get_last_progress() {
    local project="$1"
    local workstream="$2"
    local log_dir
    log_dir=$(get_log_dir "$project" "$workstream")
    local workstream_dir
    workstream_dir=$(get_workstream_dir "$project" "$workstream")

    # Try to get last lines from PROGRESS.md
    local progress_file="${workstream_dir}/PROGRESS.md"
    if [[ -f "$progress_file" ]]; then
        # Look for "Current Task" or last completed item
        local current
        current=$(grep -A1 "^## Current Task" "$progress_file" 2>/dev/null | tail -1 | sed 's/^- //')
        if [[ -n "$current" ]] && [[ "$current" != "## Current Task" ]]; then
            echo "$current"
            return
        fi

        # Fall back to last completed item
        local completed
        completed=$(grep -A10 "^## Completed" "$progress_file" 2>/dev/null | grep "^- " | tail -1 | sed 's/^- //')
        if [[ -n "$completed" ]]; then
            echo "Last: $completed"
            return
        fi
    fi

    # Fall back to log file
    if [[ -d "$log_dir" ]]; then
        local latest_log
        latest_log=$(ls -t "$log_dir"/*.log 2>/dev/null | head -1)
        if [[ -n "$latest_log" ]]; then
            # Get last meaningful line (skip Ralph prefix lines)
            tail -20 "$latest_log" 2>/dev/null | grep -v "^\[Ralph\]" | grep -v "^===" | tail -1
            return
        fi
    fi

    echo ""
}

# Format token count for display
format_tokens() {
    local count=$1
    if [[ $count -ge 1000000 ]]; then
        printf "%.1fM" "$(echo "$count / 1000000" | bc -l)"
    elif [[ $count -ge 1000 ]]; then
        printf "%.1fK" "$(echo "$count / 1000" | bc -l)"
    else
        echo "$count"
    fi
}

# Format duration from start time
format_duration() {
    local start_time=$1
    if [[ -z "$start_time" || "$start_time" == "null" || "$start_time" == "" ]]; then
        echo "-"
        return
    fi
    # Parse ISO 8601 timestamp and calculate diff
    local start_sec now_sec diff
    start_sec=$(date -j -f "%Y-%m-%dT%H:%M:%SZ" "$start_time" +%s 2>/dev/null || echo 0)
    now_sec=$(date +%s)
    diff=$((now_sec - start_sec))

    if [[ $diff -lt 0 || $start_sec -eq 0 ]]; then
        echo "-"
        return
    fi

    if [[ $diff -ge 3600 ]]; then
        printf "%dh %dm" $((diff/3600)) $(((diff%3600)/60))
    elif [[ $diff -ge 60 ]]; then
        printf "%dm" $((diff/60))
    else
        printf "%ds" $diff
    fi
}

#═══════════════════════════════════════════════════════════════
# UI Functions
#═══════════════════════════════════════════════════════════════

status_icon() {
    case $1 in
        RUNNING)     echo -e "${GREEN}⏵⏵${NC}" ;;
        STOPPED)     echo -e "${DIM}⏸${NC}" ;;
        NEEDS_INPUT) echo -e "${YELLOW}⚠️${NC}" ;;
        STUCK)       echo -e "${RED}⏸${NC}" ;;
        COMPLETE)    echo -e "${GREEN}✓${NC}" ;;
        ERROR)       echo -e "${RED}✗${NC}" ;;
        *)           echo -e "${DIM}?${NC}" ;;
    esac
}

progress_bar() {
    local current=$1
    local max=$2
    local width=15

    if [[ $max -eq 0 ]]; then max=1; fi

    local filled=$((current * width / max))
    local empty=$((width - filled))

    printf "${GREEN}"
    for ((i=0; i<filled; i++)); do printf '█'; done
    printf "${DIM}"
    for ((i=0; i<empty; i++)); do printf '░'; done
    printf "${NC}"
}

prompt_choice() {
    local prompt="$1"
    shift
    local options=("$@")

    echo ""
    echo -e "${BOLD}${prompt}${NC}"
    echo ""

    local i=1
    for opt in "${options[@]}"; do
        echo -e "  ${CYAN}${i}.${NC} ${opt}"
        ((i++))
    done
    echo ""
    echo -e "  ${DIM}c. Cancel${NC}"
    echo ""

    read -r -p "> " choice

    if [[ "$choice" == "c" ]] || [[ "$choice" == "C" ]]; then
        return 255
    fi

    if [[ "$choice" =~ ^[0-9]+$ ]] && (( choice >= 1 && choice <= ${#options[@]} )); then
        return $((choice - 1))
    fi

    return 255
}

prompt_yes_no() {
    local prompt="$1"
    local yes_desc="${2:-Proceed}"
    local no_desc="${3:-Cancel}"

    echo ""
    echo -e "${BOLD}${prompt}${NC}"
    echo ""
    echo -e "  ${CYAN}1.${NC} Yes - ${yes_desc}"
    echo -e "  ${CYAN}2.${NC} No - ${no_desc}"
    echo ""

    read -r -p "> " choice

    [[ "$choice" == "1" ]] && return 0
    return 1
}

#═══════════════════════════════════════════════════════════════
# Projects Commands
#═══════════════════════════════════════════════════════════════

cmd_projects_list() {
    echo ""
    echo -e "${BOLD}Registered Projects${NC}"
    echo "==================="
    echo ""

    local has_projects=false
    for project_file in "$RALPH_HOME/projects/"*.yaml; do
        [[ -f "$project_file" ]] || continue
        has_projects=true

        local name root type
        name=$(basename "$project_file" .yaml)
        root=$(yaml_get "$project_file" "root")
        type=$(yaml_get "$project_file" "type")

        echo -e "  ${BOLD}${name}${NC}"
        echo -e "    Root: ${CYAN}${root}${NC}"
        echo -e "    Type: ${type:-single-repo}"

        if [[ "$type" == "multi-repo" ]]; then
            local repos
            repos=$(get_project_repos "$name")
            if [[ -n "$repos" ]]; then
                echo -e "    Repos:"
                echo "$repos" | while read -r repo; do
                    echo -e "      - ${repo}"
                done
            fi
        fi
        echo ""
    done

    if ! $has_projects; then
        echo "  No projects registered"
        echo ""
        echo "  Register a project with:"
        echo "    cd /path/to/project && ralph projects add"
        echo ""
    fi
}

cmd_projects_add() {
    local multi_repo=false
    local project_root
    local project_name

    # Parse flags
    while [[ $# -gt 0 ]]; do
        case $1 in
            --multi-repo|-m)
                multi_repo=true
                shift
                ;;
            *)
                break
                ;;
        esac
    done

    # Get project root (current directory or specified)
    if [[ $# -gt 0 ]]; then
        project_root="$1"
    else
        project_root=$(pwd)
    fi

    # Resolve to absolute path
    project_root=$(cd "$project_root" && pwd)
    project_name=$(basename "$project_root")

    # Check if already registered
    if project_exists "$project_name"; then
        warn "Project '$project_name' already registered"
        echo "Use 'ralph projects update $project_name' to update"
        return 1
    fi

    local project_file
    project_file=$(get_project_file "$project_name")

    if $multi_repo; then
        # Detect repos in subdirectories
        echo -e "${CYAN}Detecting repositories in ${project_root}...${NC}"

        local repos=()
        for dir in "$project_root"/*/; do
            if [[ -d "${dir}.git" ]] || [[ -f "${dir}.git" ]]; then
                local repo_name
                repo_name=$(basename "$dir")
                repos+=("$repo_name")
                echo -e "  Found: ${GREEN}${repo_name}${NC}"
            fi
        done

        if [[ ${#repos[@]} -eq 0 ]]; then
            error "No git repositories found in subdirectories"
            echo "For single-repo projects, use: ralph projects add"
            return 1
        fi

        # Create project file
        cat > "$project_file" << EOF
name: $project_name
type: multi-repo
root: $project_root
base_branch: main
repos:
EOF
        for repo in "${repos[@]}"; do
            echo "  - path: $repo" >> "$project_file"
        done

        echo ""
        echo -e "${GREEN}Registered multi-repo project: $project_name${NC}"
        echo -e "  Root: $project_root"
        echo -e "  Repos: ${repos[*]}"
    else
        # Single repo project
        if ! git -C "$project_root" rev-parse --git-dir &>/dev/null; then
            error "Not a git repository: $project_root"
            return 1
        fi

        local base_branch
        base_branch=$(git -C "$project_root" branch --show-current)

        cat > "$project_file" << EOF
name: $project_name
type: single-repo
root: $project_root
base_branch: $base_branch
EOF

        echo ""
        echo -e "${GREEN}Registered single-repo project: $project_name${NC}"
        echo -e "  Root: $project_root"
        echo -e "  Base branch: $base_branch"
    fi

    # Create workstream directory
    mkdir -p "$RALPH_HOME/workstreams/$project_name"
}

cmd_projects_remove() {
    local project="$1"

    if [[ -z "$project" ]]; then
        error "Project name required"
        echo "Usage: ralph projects remove <name>"
        return 1
    fi

    if ! project_exists "$project"; then
        error "Project not found: $project"
        return 1
    fi

    if prompt_yes_no "Remove project '$project' from registry?" "Remove (keeps files)" "Cancel"; then
        rm -f "$(get_project_file "$project")"
        echo -e "${GREEN}Removed project: $project${NC}"
    fi
}

cmd_projects_update() {
    local project="$1"

    if [[ -z "$project" ]]; then
        error "Project name required"
        echo "Usage: ralph projects update <name>"
        return 1
    fi

    if ! project_exists "$project"; then
        error "Project not found: $project"
        return 1
    fi

    local project_root
    project_root=$(get_project_root "$project")
    local project_type
    project_type=$(get_project_type "$project")

    if [[ "$project_type" == "multi-repo" ]]; then
        echo -e "${CYAN}Re-detecting repositories in ${project_root}...${NC}"

        local project_file
        project_file=$(get_project_file "$project")
        local base_branch
        base_branch=$(yaml_get "$project_file" "base_branch")

        local repos=()
        for dir in "$project_root"/*/; do
            if [[ -d "${dir}.git" ]] || [[ -f "${dir}.git" ]]; then
                local repo_name
                repo_name=$(basename "$dir")
                repos+=("$repo_name")
                echo -e "  Found: ${GREEN}${repo_name}${NC}"
            fi
        done

        cat > "$project_file" << EOF
name: $project
type: multi-repo
root: $project_root
base_branch: ${base_branch:-main}
repos:
EOF
        for repo in "${repos[@]}"; do
            echo "  - path: $repo" >> "$project_file"
        done

        echo -e "${GREEN}Updated project: $project${NC}"
    else
        echo "Single-repo projects don't need updates"
    fi
}

cmd_projects_help() {
    echo ""
    echo -e "${BOLD}ralph projects${NC} - Manage project registry"
    echo ""
    echo -e "${CYAN}Commands:${NC}"
    echo "  ralph projects                  List registered projects"
    echo "  ralph projects add              Register current directory"
    echo "  ralph projects add --multi-repo Auto-detect repos in subdirectories"
    echo "  ralph projects remove <name>    Unregister a project"
    echo "  ralph projects update <name>    Re-detect repos (multi-repo only)"
    echo ""
}

#═══════════════════════════════════════════════════════════════
# Workstream Commands
#═══════════════════════════════════════════════════════════════

cmd_start() {
    local project="$1"
    local workstream="$2"
    local max_iter="${3:-20}"

    if [[ -z "$project" ]]; then
        error "Project required. Use -p <project> or cd into project directory."
        return 1
    fi

    if [[ -z "$workstream" ]]; then
        error "Workstream name required"
        echo "Usage: ralph start <workstream> [max-iterations]"
        return 1
    fi

    if ! project_exists "$project"; then
        error "Project not found: $project"
        echo "Register with: ralph projects add"
        return 1
    fi

    local project_type
    project_type=$(get_project_type "$project")
    local project_root
    project_root=$(get_project_root "$project")
    local worktree_path
    worktree_path=$(get_worktree_path "$project" "$workstream")
    local session_name
    session_name=$(get_session_name "$project" "$workstream")
    local workstream_dir
    workstream_dir=$(get_workstream_dir "$project" "$workstream")
    local state_dir
    state_dir=$(get_state_dir "$project" "$workstream")
    local log_dir
    log_dir=$(get_log_dir "$project" "$workstream")

    # Check if worktree already exists
    if [[ -d "$worktree_path" ]]; then
        echo -e "${YELLOW}Worktree already exists: $worktree_path${NC}"
        if prompt_yes_no "Attach to existing session?" "Attach" "Cancel"; then
            tmux attach -t "$session_name" 2>/dev/null || echo "No session running"
        fi
        return
    fi

    # Check for PROMPT.md
    if [[ ! -f "${workstream_dir}/PROMPT.md" ]]; then
        echo -e "${YELLOW}No PROMPT.md found for workstream '${workstream}'${NC}"
        if prompt_yes_no "Create new workstream?" "Create" "Cancel"; then
            mkdir -p "$workstream_dir"
            read -r -p "Brief description: " desc
            cat > "${workstream_dir}/PROMPT.md" << EOF
# Ralph Workstream: ${workstream}

## Objective
${desc}

## Instructions
1. Read PROGRESS.md to see what's already done
2. Pick the next task
3. Implement with minimal changes
4. Run build/tests to verify
5. Update PROGRESS.md
6. If all tasks complete, add "## Status: COMPLETE"

## Constraints
- One logical change per iteration
- Always verify changes compile
- Follow existing code patterns
EOF
            echo -e "${GREEN}Created ${workstream_dir}/PROMPT.md${NC}"
            echo "Edit it, then run: ralph -p $project start $workstream"
            return
        else
            return
        fi
    fi

    # Create directories
    mkdir -p "$state_dir" "$log_dir"

    if [[ "$project_type" == "multi-repo" ]]; then
        # Multi-repo: create unified worktree directory
        echo -e "${CYAN}Creating multi-repo worktree: $worktree_path${NC}"
        mkdir -p "$worktree_path"

        local repos
        repos=$(get_project_repos "$project")

        for repo in $repos; do
            local repo_path="${project_root}/${repo}"
            local branch="ralph/${workstream}"

            echo -e "  Creating worktree for ${CYAN}${repo}${NC}..."
            cd "$repo_path"
            git worktree add "${worktree_path}/${repo}" -b "$branch" 2>/dev/null || \
            git worktree add "${worktree_path}/${repo}" "$branch" 2>/dev/null || {
                error "Failed to create worktree for $repo"
                return 1
            }
        done

        # Link workstream config
        ln -sf "$workstream_dir" "${worktree_path}/.ralph-config"
    else
        # Single-repo: create worktree
        echo -e "${CYAN}Creating worktree: $worktree_path${NC}"
        cd "$project_root"
        local branch="ralph/${workstream}"
        git worktree add "$worktree_path" -b "$branch" 2>/dev/null || \
        git worktree add "$worktree_path" "$branch"

        # Copy config to worktree
        mkdir -p "${worktree_path}/.ralph/${workstream}"
        cp "${workstream_dir}/PROMPT.md" "${worktree_path}/.ralph/${workstream}/"
        [[ -f "${workstream_dir}/PROGRESS.md" ]] && \
            cp "${workstream_dir}/PROGRESS.md" "${worktree_path}/.ralph/${workstream}/"
    fi

    # Initialize state
    echo "0" > "${state_dir}/iteration"
    echo "RUNNING" > "${state_dir}/status"

    # Start tmux session
    local log_file="${log_dir}/$(date +%Y-%m-%dT%H-%M-%S).log"
    echo -e "${CYAN}Starting Ralph in tmux session: $session_name${NC}"

    tmux new-session -d -s "$session_name" -c "$worktree_path" \
        "RALPH_HOME='$RALPH_HOME' MAX_ITERATIONS=$max_iter $RALPH_HOME/bin/ralph-loop.sh '$project' '$workstream' 2>&1 | tee '$log_file'; echo 'Ralph finished. Press enter to close...'; read"

    # Send notification
    notify "Ralph Started" "${project}/${workstream} (${max_iter} iterations)"

    echo ""
    echo -e "${GREEN}Ralph started!${NC}"
    echo -e "  Project:    ${CYAN}$project${NC}"
    echo -e "  Workstream: ${CYAN}$workstream${NC}"
    echo -e "  Worktree:   ${CYAN}$worktree_path${NC}"
    echo -e "  Session:    ${CYAN}$session_name${NC}"
    echo ""
    echo "Commands:"
    echo "  ralph -p $project attach $workstream  - Watch live"
    echo "  ralph -p $project stop $workstream    - Stop gracefully"
    echo "  ralph -p $project status              - Check progress"
}

cmd_stop() {
    local project="$1"
    local workstream="$2"

    if [[ -z "$project" ]]; then
        error "Project required"
        return 1
    fi

    if [[ -z "$workstream" ]] || [[ "$workstream" == "--all" ]]; then
        # Stop all workstreams for project
        local sessions
        sessions=$(tmux list-sessions -F "#{session_name}" 2>/dev/null | grep "^ralph-${project}-" || true)

        if [[ -z "$sessions" ]]; then
            echo "No Ralph sessions running for $project"
            return
        fi

        if prompt_yes_no "Stop all workstreams for $project?" "Stop all" "Cancel"; then
            for session in $sessions; do
                echo -e "Stopping ${CYAN}${session}${NC}..."
                tmux send-keys -t "$session" C-c
            done
            echo -e "${GREEN}All workstreams signaled to stop${NC}"
        fi
    else
        local session
        session=$(get_session_name "$project" "$workstream")
        local state_dir
        state_dir=$(get_state_dir "$project" "$workstream")

        if tmux has-session -t "$session" 2>/dev/null; then
            tmux send-keys -t "$session" C-c
            echo "STOPPING" > "${state_dir}/status"
            echo -e "${GREEN}Ralph (${project}/${workstream}) will stop${NC}"
        else
            touch "${state_dir}/stop"
            echo -e "${GREEN}Stop signal sent to ${project}/${workstream}${NC}"
        fi
    fi
}

cmd_status() {
    local project="$1"

    if [[ -z "$project" ]]; then
        error "Project required"
        return 1
    fi

    if ! project_exists "$project"; then
        error "Project not found: $project"
        return 1
    fi

    local workstreams
    workstreams=($(get_workstreams "$project"))

    if [[ ${#workstreams[@]} -eq 0 ]]; then
        echo ""
        echo -e "${BOLD}Ralph Workstreams - $project${NC}"
        echo "=============================="
        echo ""
        echo "No workstreams running"
        echo ""
        echo "Start one with: ralph -p $project start <name>"
        return
    fi

    # Table header
    echo ""
    printf "┌─────────────────┬──────────┬────────────┬──────────┬─────────┬──────────┐\n"
    printf "│ %-15s │ %-8s │ %-10s │ %-8s │ %-7s │ %-8s │\n" \
           "Workstream" "Status" "Progress" "Tokens" "Cost" "Duration"
    printf "├─────────────────┼──────────┼────────────┼──────────┼─────────┼──────────┤\n"

    for ws in "${workstreams[@]}"; do
        local status iteration metrics
        status=$(get_status "$project" "$ws")
        iteration=$(get_iteration "$project" "$ws")
        metrics=$(get_metrics "$project" "$ws")

        local max_iter tokens_in tokens_out total_tokens cost start_time end_time
        max_iter=$(echo "$metrics" | jq -r '.max_iterations // 100')
        tokens_in=$(echo "$metrics" | jq -r '.tokens_in // 0')
        tokens_out=$(echo "$metrics" | jq -r '.tokens_out // 0')
        total_tokens=$((tokens_in + tokens_out))
        cost=$(echo "$metrics" | jq -r '.total_cost // 0')
        start_time=$(echo "$metrics" | jq -r '.start_time // ""')
        end_time=$(echo "$metrics" | jq -r '.end_time // ""')

        local progress_pct=0
        [[ $max_iter -gt 0 ]] && progress_pct=$((iteration * 100 / max_iter))

        local tokens_fmt cost_fmt duration_fmt progress_fmt
        tokens_fmt=$(format_tokens "$total_tokens")
        cost_fmt=$(printf "\$%.2f" "$cost")

        # Use end_time for stopped/complete workstreams, now for running
        if [[ "$status" == "RUNNING" ]] || [[ -z "$end_time" ]] || [[ "$end_time" == "null" ]]; then
            duration_fmt=$(format_duration "$start_time")
        else
            duration_fmt=$(format_duration_between "$start_time" "$end_time")
        fi

        # Progress display: DONE for complete, percentage otherwise
        if [[ "$status" == "COMPLETE" ]]; then
            progress_fmt="  DONE    "
        else
            progress_fmt=$(printf "%2d/%-3d %2d%%" "$iteration" "$max_iter" "$progress_pct")
        fi

        # Status with color (8 chars max for column)
        local status_display
        case "$status" in
            RUNNING)     status_display="${GREEN}RUNNING${NC}" ;;
            COMPLETE)    status_display="${GREEN}COMPLETE${NC}" ;;
            STOPPED)     status_display="${DIM}STOPPED${NC}" ;;
            NEEDS_INPUT) status_display="${YELLOW}NEEDS_IN${NC}" ;;
            STUCK)       status_display="${RED}STUCK${NC}" ;;
            ERROR)       status_display="${RED}ERROR${NC}" ;;
            *)           status_display="$status" ;;
        esac

        # Truncate workstream name to 15 chars
        local ws_short="${ws:0:15}"

        # Print row - use printf with -e for color codes
        printf "│ %-15s │ " "$ws_short"
        printf "${status_display}"
        # Pad status column (8 chars visible, but colors add invisible chars)
        local visible_len=${#status}
        local pad=$((8 - visible_len))
        printf "%${pad}s │ %-10s │ %-8s │ %-7s │ %-8s │\n" \
               "" "$progress_fmt" "$tokens_fmt" "$cost_fmt" "$duration_fmt"
    done

    printf "└─────────────────┴──────────┴────────────┴──────────┴─────────┴──────────┘\n"
    echo ""
}

cmd_attach() {
    local project="$1"
    local workstream="$2"

    if [[ -z "$project" ]] || [[ -z "$workstream" ]]; then
        error "Project and workstream required"
        echo "Usage: ralph -p <project> attach <workstream>"
        return 1
    fi

    local session
    session=$(get_session_name "$project" "$workstream")

    if tmux has-session -t "$session" 2>/dev/null; then
        tmux attach -t "$session"
    else
        error "No session found: $session"
    fi
}

cmd_answer() {
    local project="$1"
    local workstream="$2"

    if [[ -z "$project" ]]; then
        error "Project required"
        return 1
    fi

    # Find workstream with question if not specified
    if [[ -z "$workstream" ]]; then
        for ws in $(get_workstreams "$project"); do
            local state_dir
            state_dir=$(get_state_dir "$project" "$ws")
            if [[ -f "${state_dir}/question" ]]; then
                workstream="$ws"
                break
            fi
        done
    fi

    if [[ -z "$workstream" ]]; then
        echo "No questions pending for $project"
        return
    fi

    local state_dir
    state_dir=$(get_state_dir "$project" "$workstream")
    local question_file="${state_dir}/question"

    if [[ ! -f "$question_file" ]]; then
        echo "No question pending for $workstream"
        return
    fi

    echo ""
    echo -e "${BOLD}Question from ${CYAN}${project}/${workstream}${NC}:${NC}"
    echo ""
    cat "$question_file"
    echo ""
    echo -e "${DIM}Type your answer (or 'skip' to defer):${NC}"
    read -r -p "> " answer

    if [[ "$answer" != "skip" ]]; then
        echo "$answer" > "${state_dir}/answer"
        rm -f "$question_file"
        echo -e "${GREEN}Answer sent to Ralph${NC}"
    fi
}

cmd_cleanup() {
    local project="$1"
    local workstream="$2"

    if [[ -z "$project" ]] || [[ -z "$workstream" ]]; then
        error "Project and workstream required"
        echo "Usage: ralph -p <project> cleanup <workstream>"
        return 1
    fi

    local project_type
    project_type=$(get_project_type "$project")
    local project_root
    project_root=$(get_project_root "$project")
    local worktree_path
    worktree_path=$(get_worktree_path "$project" "$workstream")
    local session
    session=$(get_session_name "$project" "$workstream")

    # Kill session if running
    if tmux has-session -t "$session" 2>/dev/null; then
        echo -e "${YELLOW}Stopping running session...${NC}"
        tmux kill-session -t "$session"
    fi

    if [[ "$project_type" == "multi-repo" ]]; then
        # Multi-repo cleanup
        local repos
        repos=$(get_project_repos "$project")
        local branch="ralph/${workstream}"
        local all_clean=true

        # Check for uncommitted changes in all repos
        for repo in $repos; do
            local repo_worktree="${worktree_path}/${repo}"
            if [[ -d "$repo_worktree" ]]; then
                cd "$repo_worktree"
                if [[ -n $(git status --porcelain 2>/dev/null) ]]; then
                    echo -e "${YELLOW}Uncommitted changes in ${repo}${NC}"
                    git status --short
                    all_clean=false
                fi
            fi
        done

        if ! $all_clean; then
            if ! prompt_yes_no "Discard all uncommitted changes?" "Discard" "Cancel"; then
                return
            fi
        fi

        # Merge each repo
        echo -e "${CYAN}Merging all repos...${NC}"
        local merge_failed=false

        for repo in $repos; do
            local repo_path="${project_root}/${repo}"
            cd "$repo_path"

            if git show-ref --verify --quiet "refs/heads/${branch}"; then
                echo -e "  Merging ${CYAN}${repo}${NC}..."
                if ! git merge "$branch" --no-edit 2>/dev/null; then
                    error "Merge conflict in $repo"
                    merge_failed=true
                    break
                fi
            fi
        done

        if $merge_failed; then
            error "Merge failed. Resolve conflicts manually, then:"
            echo "  1. Complete merge in each repo"
            echo "  2. Remove worktrees: rm -rf $worktree_path"
            echo "  3. Delete branches in each repo"
            return 1
        fi

        # Remove worktrees
        echo -e "${CYAN}Removing worktrees...${NC}"
        for repo in $repos; do
            local repo_path="${project_root}/${repo}"
            cd "$repo_path"
            git worktree remove "${worktree_path}/${repo}" --force 2>/dev/null || true
            git branch -d "$branch" 2>/dev/null || true
        done

        rm -rf "$worktree_path"
    else
        # Single-repo cleanup
        cd "$project_root"
        local branch="ralph/${workstream}"

        if [[ -d "$worktree_path" ]]; then
            cd "$worktree_path"
            if [[ -n $(git status --porcelain 2>/dev/null) ]]; then
                echo -e "${YELLOW}Uncommitted changes in worktree${NC}"
                git status --short
                if ! prompt_yes_no "Discard changes?" "Discard" "Cancel"; then
                    return
                fi
            fi
            cd "$project_root"
        fi

        echo -e "${CYAN}Merging $branch...${NC}"
        if git merge "$branch" --no-edit; then
            echo -e "${GREEN}Merge successful!${NC}"
        else
            error "Merge conflicts detected"
            echo "Resolve conflicts, then run:"
            echo "  git worktree remove $worktree_path"
            echo "  git branch -d $branch"
            return 1
        fi

        git worktree remove "$worktree_path" --force 2>/dev/null || true
        git branch -d "$branch" 2>/dev/null || true
    fi

    # Archive metrics before cleanup
    archive_workstream "$project" "$workstream" "MERGED"

    # Clean up state
    local state_dir
    state_dir=$(get_state_dir "$project" "$workstream")
    rm -rf "$state_dir"

    notify "Ralph Cleanup" "Merged ${project}/${workstream}"
    echo -e "${GREEN}Cleanup complete!${NC}"
}

cmd_logs() {
    local project="$1"
    local workstream="$2"

    if [[ -z "$project" ]] || [[ -z "$workstream" ]]; then
        error "Project and workstream required"
        return 1
    fi

    local log_dir
    log_dir=$(get_log_dir "$project" "$workstream")

    if [[ ! -d "$log_dir" ]]; then
        echo "No logs found for ${project}/${workstream}"
        return
    fi

    local latest_log
    latest_log=$(ls -t "$log_dir"/*.log 2>/dev/null | head -1)

    if [[ -n "$latest_log" ]]; then
        tail -f "$latest_log"
    else
        echo "No log files found"
    fi
}

cmd_note() {
    local project="$1"
    local workstream="$2"
    shift 2
    local note_text="$*"

    if [[ -z "$project" ]] || [[ -z "$workstream" ]]; then
        error "Project and workstream required"
        echo "Usage: ralph -p <project> note <workstream> \"note text\""
        echo "       ralph -p <project> note <workstream> --clear"
        return 1
    fi

    local state_dir
    state_dir=$(get_state_dir "$project" "$workstream")
    local note_file="${state_dir}/note"

    if [[ ! -d "$state_dir" ]]; then
        error "Workstream not found: ${project}/${workstream}"
        return 1
    fi

    if [[ "$note_text" == "--clear" ]] || [[ "$note_text" == "-c" ]]; then
        rm -f "$note_file"
        echo -e "${GREEN}Note cleared for ${project}/${workstream}${NC}"
        return
    fi

    if [[ -z "$note_text" ]]; then
        # Show current note
        if [[ -f "$note_file" ]]; then
            echo -e "${BOLD}Note for ${project}/${workstream}:${NC}"
            cat "$note_file"
        else
            echo "No note set for ${project}/${workstream}"
        fi
        return
    fi

    # Set the note
    echo "$note_text" > "$note_file"
    echo -e "${GREEN}Note set for ${project}/${workstream}${NC}"
}

cmd_notes() {
    local project="$1"

    if [[ -z "$project" ]]; then
        # Show all notes across all projects
        echo ""
        echo -e "${BOLD}Workstream Notes${NC}"
        echo "================"
        echo ""

        local has_notes=false
        for project_file in "$RALPH_HOME/projects/"*.yaml; do
            [[ -f "$project_file" ]] || continue
            local proj
            proj=$(basename "$project_file" .yaml)

            for ws in $(get_workstreams "$proj"); do
                local note
                note=$(get_note "$proj" "$ws")
                if [[ -n "$note" ]]; then
                    has_notes=true
                    echo -e "  ${CYAN}${proj}/${ws}${NC}: $note"
                fi
            done
        done

        if ! $has_notes; then
            echo "  No notes set"
        fi
        echo ""
    else
        # Show notes for specific project
        echo ""
        echo -e "${BOLD}Notes for $project${NC}"
        echo "================"
        echo ""

        local has_notes=false
        for ws in $(get_workstreams "$project"); do
            local note
            note=$(get_note "$project" "$ws")
            if [[ -n "$note" ]]; then
                has_notes=true
                echo -e "  ${CYAN}${ws}${NC}: $note"
            fi
        done

        if ! $has_notes; then
            echo "  No notes set"
        fi
        echo ""
    fi
}

#═══════════════════════════════════════════════════════════════
# Recovery
#═══════════════════════════════════════════════════════════════

cmd_recover() {
    echo -e "${CYAN}Checking for orphaned workstreams...${NC}"
    local recovered=0

    for project_file in "$RALPH_HOME/projects/"*.yaml; do
        [[ -f "$project_file" ]] || continue

        local project
        project=$(basename "$project_file" .yaml)
        local project_root
        project_root=$(get_project_root "$project")

        [[ -d "$project_root" ]] || continue

        for ws in $(get_workstreams "$project"); do
            local session
            session=$(get_session_name "$project" "$ws")
            local state_dir
            state_dir=$(get_state_dir "$project" "$ws")

            # Check if tmux session exists
            if ! tmux has-session -t "$session" 2>/dev/null; then
                # Check if state says RUNNING
                if [[ -f "${state_dir}/status" ]] && [[ "$(cat "${state_dir}/status")" == "RUNNING" ]]; then
                    echo -e "  Found orphaned: ${YELLOW}${project}/${ws}${NC}"
                    echo "STOPPED" > "${state_dir}/status"
                    ((recovered++))
                fi
            fi
        done
    done

    if [[ $recovered -gt 0 ]]; then
        notify "Ralph Recovered" "Found $recovered orphaned workstream(s)"
        echo -e "${GREEN}Recovered $recovered orphaned workstream(s)${NC}"
    else
        echo "No orphaned workstreams found"
    fi
}

cmd_prune() {
    local project="$1"
    local dry_run=false
    local pruned=0

    if [[ "$project" == "--dry-run" ]]; then
        dry_run=true
        project=""
    fi

    echo -e "${CYAN}Scanning for stale workstreams...${NC}"
    echo ""

    local projects_to_check=()
    if [[ -n "$project" ]]; then
        projects_to_check=("$project")
    else
        for project_file in "$RALPH_HOME/projects/"*.yaml; do
            [[ -f "$project_file" ]] || continue
            projects_to_check+=("$(basename "$project_file" .yaml)")
        done
    fi

    for proj in "${projects_to_check[@]}"; do
        local state_base="$RALPH_HOME/state/${proj}"
        [[ -d "$state_base" ]] || continue

        for ws_dir in "$state_base"/*/; do
            [[ -d "$ws_dir" ]] || continue
            local ws
            ws=$(basename "$ws_dir")
            local session
            session=$(get_session_name "$proj" "$ws")
            local status_file="${ws_dir}/status"

            # Check if this workstream is stale:
            # - tmux session doesn't exist
            # - status is not RUNNING (or status file doesn't exist)
            local is_stale=false
            local reason=""

            if ! tmux has-session -t "$session" 2>/dev/null; then
                if [[ -f "$status_file" ]]; then
                    local status
                    status=$(cat "$status_file")
                    if [[ "$status" != "RUNNING" ]]; then
                        is_stale=true
                        reason="stopped (status: $status)"
                    fi
                else
                    is_stale=true
                    reason="no status file"
                fi
            fi

            if $is_stale; then
                echo -e "  ${YELLOW}${proj}/${ws}${NC} - $reason"
                if ! $dry_run; then
                    # Archive before pruning
                    local final_status
                    final_status=$(cat "$status_file" 2>/dev/null || echo "PRUNED")
                    archive_workstream "$proj" "$ws" "$final_status"

                    rm -rf "$ws_dir"
                    # Also clean up logs if empty
                    local log_dir="$RALPH_HOME/logs/${proj}/${ws}"
                    if [[ -d "$log_dir" ]]; then
                        rm -rf "$log_dir"
                    fi
                    ((pruned++))
                fi
            fi
        done

        # Clean up empty project state directories
        if ! $dry_run && [[ -d "$state_base" ]] && [[ -z "$(ls -A "$state_base")" ]]; then
            rmdir "$state_base" 2>/dev/null
        fi
    done

    echo ""
    if $dry_run; then
        echo -e "${DIM}Dry run - no changes made. Run without --dry-run to prune.${NC}"
    elif [[ $pruned -gt 0 ]]; then
        echo -e "${GREEN}Pruned $pruned stale workstream(s)${NC}"
    else
        echo "No stale workstreams found"
    fi
}

cmd_history() {
    local show_all=false
    local project_filter=""

    # Parse args
    while [[ $# -gt 0 ]]; do
        case $1 in
            --all|-a) show_all=true; shift ;;
            *) project_filter="$1"; shift ;;
        esac
    done

    local history_file="$RALPH_HOME/archive/history.json"

    if [[ ! -f "$history_file" ]]; then
        echo ""
        echo "No history found"
        echo ""
        echo "History is recorded when workstreams are cleaned up, pruned, or auto-merged."
        return
    fi

    # Build list of active workstreams to filter out (unless --all)
    local active_list=""
    for project_file in "$RALPH_HOME/projects/"*.yaml; do
        [[ -f "$project_file" ]] || continue
        local proj
        proj=$(basename "$project_file" .yaml)
        for ws in $(get_workstreams "$proj"); do
            active_list="${active_list}${proj}/${ws}"$'\n'
        done
    done

    # Table header
    echo ""
    printf "┌─────────────────┬─────────────────┬──────────┬──────────┬─────────┬──────────┬────────────┐\n"
    printf "│ %-15s │ %-15s │ %-8s │ %-8s │ %-7s │ %-8s │ %-10s │\n" \
           "Project" "Workstream" "Status" "Tokens" "Cost" "Duration" "Date"
    printf "├─────────────────┼─────────────────┼──────────┼──────────┼─────────┼──────────┼────────────┤\n"

    local row_count=0

    # Read history file and display
    while IFS= read -r line; do
        [[ -z "$line" ]] && continue

        local proj ws status tokens_in tokens_out cost start_time end_time
        proj=$(echo "$line" | jq -r '.project // ""')
        ws=$(echo "$line" | jq -r '.workstream // ""')
        status=$(echo "$line" | jq -r '.status // "UNKNOWN"')
        tokens_in=$(echo "$line" | jq -r '.tokens_in // 0')
        tokens_out=$(echo "$line" | jq -r '.tokens_out // 0')
        cost=$(echo "$line" | jq -r '.total_cost // 0')
        start_time=$(echo "$line" | jq -r '.start_time // ""')
        end_time=$(echo "$line" | jq -r '.end_time // ""')

        # Skip empty records
        [[ -z "$proj" || -z "$ws" ]] && continue

        # Filter by project if specified
        if [[ -n "$project_filter" ]] && [[ "$proj" != "$project_filter" ]]; then
            continue
        fi

        # Skip active workstreams unless --all
        if ! $show_all && echo "$active_list" | grep -q "^${proj}/${ws}$"; then
            continue
        fi

        # Format values
        local total_tokens=$((tokens_in + tokens_out))
        local tokens_fmt cost_fmt duration_fmt date_fmt
        tokens_fmt=$(format_tokens "$total_tokens")
        cost_fmt=$(printf "\$%.2f" "$cost")
        duration_fmt=$(format_duration_between "$start_time" "$end_time")
        date_fmt=$(echo "$end_time" | cut -dT -f1)

        # Truncate names to 15 chars
        local proj_short="${proj:0:15}"
        local ws_short="${ws:0:15}"

        # Status with color (truncate to 8 chars for display)
        local status_short="${status:0:8}"
        local status_display
        case "$status" in
            COMPLETE|MERGED) status_display="${GREEN}${status_short}${NC}" ;;
            STOPPED|PRUNED)  status_display="${DIM}${status_short}${NC}" ;;
            ERROR)           status_display="${RED}${status_short}${NC}" ;;
            *)               status_display="$status_short" ;;
        esac

        # Print row with color
        printf "│ %-15s │ %-15s │ " "$proj_short" "$ws_short"
        printf "${status_display}"
        printf "%*s │ %-8s │ %-7s │ %-8s │ %-10s │\n" \
               $((8 - ${#status_short})) "" "$tokens_fmt" "$cost_fmt" "$duration_fmt" "$date_fmt"

        ((row_count++))
    done < "$history_file"

    printf "└─────────────────┴─────────────────┴──────────┴──────────┴─────────┴──────────┴────────────┘\n"

    if [[ $row_count -eq 0 ]]; then
        echo ""
        if $show_all; then
            echo "No workstream history recorded yet."
        else
            echo "No historical workstreams (use --all to include active)"
        fi
    fi
    echo ""
}

#═══════════════════════════════════════════════════════════════
# Global Status (Non-Interactive)
#═══════════════════════════════════════════════════════════════

cmd_status_global() {
    echo ""
    echo -e "${BOLD}Ralph Status${NC}"
    echo "═══════════════════════════════════════════════════════════════════════════════"
    echo ""

    # Collect all workstreams across all projects
    local has_active=false
    local all_rows=()
    local attention_items=()
    local notes_items=()

    for project_file in "$RALPH_HOME/projects/"*.yaml; do
        [[ -f "$project_file" ]] || continue

        local project
        project=$(basename "$project_file" .yaml)
        local workstreams_str
        workstreams_str=$(get_workstreams "$project")

        if [[ -n "$workstreams_str" ]]; then
            for ws in $workstreams_str; do
                has_active=true
                all_rows+=("$project|$ws")

                # Check for issues
                local issue
                if issue=$(detect_workstream_issues "$project" "$ws"); then
                    local issue_type issue_desc last_progress
                    issue_type=$(echo "$issue" | cut -d'|' -f1)
                    issue_desc=$(echo "$issue" | cut -d'|' -f2-)
                    last_progress=$(get_last_progress "$project" "$ws")
                    attention_items+=("$project|$ws|$issue_type|$issue_desc|$last_progress")
                fi

                # Check for notes
                local note
                note=$(get_note "$project" "$ws")
                if [[ -n "$note" ]]; then
                    notes_items+=("$project|$ws|$note")
                fi
            done
        fi
    done

    if ! $has_active; then
        echo "No active workstreams"
        echo ""
        echo "Start one with: ralph -p <project> start <workstream>"
        return
    fi

    # Table header with Notes column
    printf "┌─────────────────┬─────────────────┬──────────┬────────────┬──────────┬─────────┬──────────┬───────┐\n"
    printf "│ %-15s │ %-15s │ %-8s │ %-10s │ %-8s │ %-7s │ %-8s │ %-5s │\n" \
           "Project" "Workstream" "Status" "Progress" "Tokens" "Cost" "Duration" "Notes"
    printf "├─────────────────┼─────────────────┼──────────┼────────────┼──────────┼─────────┼──────────┼───────┤\n"

    for row in "${all_rows[@]}"; do
        local project ws
        project=$(echo "$row" | cut -d'|' -f1)
        ws=$(echo "$row" | cut -d'|' -f2)

        local status iteration metrics
        status=$(get_status "$project" "$ws")
        iteration=$(get_iteration "$project" "$ws")
        metrics=$(get_metrics "$project" "$ws")

        local max_iter tokens_in tokens_out total_tokens cost start_time end_time
        max_iter=$(echo "$metrics" | jq -r '.max_iterations // 100')
        tokens_in=$(echo "$metrics" | jq -r '.tokens_in // 0')
        tokens_out=$(echo "$metrics" | jq -r '.tokens_out // 0')
        total_tokens=$((tokens_in + tokens_out))
        cost=$(echo "$metrics" | jq -r '.total_cost // 0')
        start_time=$(echo "$metrics" | jq -r '.start_time // ""')
        end_time=$(echo "$metrics" | jq -r '.end_time // ""')

        local progress_pct=0
        [[ $max_iter -gt 0 ]] && progress_pct=$((iteration * 100 / max_iter))

        local tokens_fmt cost_fmt duration_fmt progress_fmt
        tokens_fmt=$(format_tokens "$total_tokens")
        cost_fmt=$(printf "\$%.2f" "$cost")

        # Use end_time for stopped/complete workstreams, now for running
        if [[ "$status" == "RUNNING" ]] || [[ -z "$end_time" ]] || [[ "$end_time" == "null" ]]; then
            duration_fmt=$(format_duration "$start_time")
        else
            duration_fmt=$(format_duration_between "$start_time" "$end_time")
        fi

        # Progress display: DONE for complete, percentage otherwise
        if [[ "$status" == "COMPLETE" ]]; then
            progress_fmt="  DONE    "
        else
            progress_fmt=$(printf "%2d/%-3d %2d%%" "$iteration" "$max_iter" "$progress_pct")
        fi

        # Truncate names to 15 chars
        local proj_short="${project:0:15}"
        local ws_short="${ws:0:15}"

        # Note indicator
        local note_indicator="     "
        local note
        note=$(get_note "$project" "$ws")
        if [[ -n "$note" ]]; then
            note_indicator="  📝 "
        fi

        # Status with color
        local status_display
        case "$status" in
            RUNNING)     status_display="${GREEN}RUNNING${NC}" ;;
            COMPLETE)    status_display="${GREEN}COMPLETE${NC}" ;;
            STOPPED)     status_display="${DIM}STOPPED${NC}" ;;
            NEEDS_INPUT) status_display="${YELLOW}NEEDS_IN${NC}" ;;
            STUCK)       status_display="${RED}STUCK${NC}" ;;
            ERROR)       status_display="${RED}ERROR${NC}" ;;
            *)           status_display="$status" ;;
        esac

        echo -e "│ $(printf '%-15s' "$proj_short") │ $(printf '%-15s' "$ws_short") │ ${status_display}$(printf '%*s' $((8 - ${#status})) '') │ $(printf '%-10s' "$progress_fmt") │ $(printf '%-8s' "$tokens_fmt") │ $(printf '%-7s' "$cost_fmt") │ $(printf '%-8s' "$duration_fmt") │${note_indicator}│"
    done

    printf "└─────────────────┴─────────────────┴──────────┴────────────┴──────────┴─────────┴──────────┴───────┘\n"

    # Needs Attention section
    if [[ ${#attention_items[@]} -gt 0 ]]; then
        echo ""
        echo -e "${YELLOW}⚠️  Needs Attention${NC}"
        echo "───────────────────"

        for item in "${attention_items[@]}"; do
            local proj ws issue_type issue_desc last_progress
            proj=$(echo "$item" | cut -d'|' -f1)
            ws=$(echo "$item" | cut -d'|' -f2)
            issue_type=$(echo "$item" | cut -d'|' -f3)
            issue_desc=$(echo "$item" | cut -d'|' -f4)
            last_progress=$(echo "$item" | cut -d'|' -f5)

            # Issue icon
            local icon
            case "$issue_type" in
                NEEDS_INPUT) icon="${YELLOW}❓${NC}" ;;
                ERROR)       icon="${RED}✗${NC}" ;;
                STUCK)       icon="${RED}⏸${NC}" ;;
                COMPLETE)    icon="${GREEN}✓${NC}" ;;
                MAX_ITER)    icon="${YELLOW}🔄${NC}" ;;
                ORPHANED)    icon="${RED}💀${NC}" ;;
                *)           icon="•" ;;
            esac

            echo -e "  $icon ${CYAN}${proj}/${ws}${NC} - $issue_desc"

            # Show last progress if available
            if [[ -n "$last_progress" ]]; then
                echo -e "     └─ ${DIM}$last_progress${NC}"
            fi

            # Suggest action
            local action=""
            case "$issue_type" in
                NEEDS_INPUT) action="ralph -p $proj answer $ws" ;;
                ERROR)       action="ralph -p $proj logs $ws" ;;
                COMPLETE)    action="ralph -p $proj cleanup $ws" ;;
                MAX_ITER)    action="ralph -p $proj cleanup $ws  # or restart with more iterations" ;;
                ORPHANED)    action="ralph recover" ;;
            esac
            if [[ -n "$action" ]]; then
                echo -e "     └─ ${DIM}Action: ${action}${NC}"
            fi
        done
    fi

    # Notes section
    if [[ ${#notes_items[@]} -gt 0 ]]; then
        echo ""
        echo -e "${CYAN}📝 Workstream Notes${NC}"
        echo "───────────────────"

        for item in "${notes_items[@]}"; do
            local proj ws note
            proj=$(echo "$item" | cut -d'|' -f1)
            ws=$(echo "$item" | cut -d'|' -f2)
            note=$(echo "$item" | cut -d'|' -f3-)

            echo -e "  • ${BOLD}${proj}/${ws}${NC}: $note"
        done
    fi

    echo ""
    echo -e "${DIM}Quick commands: ralph -p <project> [attach|stop|cleanup|answer|logs] <workstream>${NC}"
    echo ""
}

#═══════════════════════════════════════════════════════════════
# Live Progress Streaming (ralph watch)
#═══════════════════════════════════════════════════════════════

EVENTS_DIR="$RALPH_HOME/events"
EVENTS_FILE="$EVENTS_DIR/stream"

# Format a single event for human-readable output
format_event() {
    local line="$1"

    # Parse JSON fields
    local ts project ws event
    ts=$(echo "$line" | jq -r '.ts // ""' 2>/dev/null)
    project=$(echo "$line" | jq -r '.project // ""' 2>/dev/null)
    ws=$(echo "$line" | jq -r '.ws // ""' 2>/dev/null)
    event=$(echo "$line" | jq -r '.event // ""' 2>/dev/null)

    [[ -z "$project" ]] || [[ -z "$ws" ]] && return

    # Format timestamp (just HH:MM:SS)
    local time_fmt
    time_fmt=$(echo "$ts" | sed 's/.*T\([0-9:]*\)Z/\1/')

    # Format based on event type
    case "$event" in
        iteration_start)
            local iter max
            iter=$(echo "$line" | jq -r '.iter // 0')
            max=$(echo "$line" | jq -r '.max // 20')
            echo -e "${DIM}${time_fmt}${NC} ${CYAN}${project}/${ws}${NC} ${GREEN}▶${NC} Starting iteration ${BOLD}${iter}/${max}${NC}"
            ;;
        iteration_end)
            local iter exit_code cost tokens_in tokens_out
            iter=$(echo "$line" | jq -r '.iter // 0')
            exit_code=$(echo "$line" | jq -r '.exit_code // 0')
            cost=$(echo "$line" | jq -r '.cost // 0')
            tokens_in=$(echo "$line" | jq -r '.tokens_in // 0')
            tokens_out=$(echo "$line" | jq -r '.tokens_out // 0')
            local total_tokens=$((tokens_in + tokens_out))
            local tokens_fmt
            if [[ $total_tokens -ge 1000000 ]]; then
                tokens_fmt="$(awk "BEGIN {printf \"%.1fM\", $total_tokens/1000000}")"
            elif [[ $total_tokens -ge 1000 ]]; then
                tokens_fmt="$(awk "BEGIN {printf \"%.0fK\", $total_tokens/1000}")"
            else
                tokens_fmt="${total_tokens}"
            fi
            local status_icon
            if [[ $exit_code -eq 0 ]]; then
                status_icon="${GREEN}✓${NC}"
            else
                status_icon="${RED}✗${NC}"
            fi
            echo -e "${DIM}${time_fmt}${NC} ${CYAN}${project}/${ws}${NC} ${status_icon} Iter ${iter} done │ \$$(printf '%.2f' "$cost") │ ${tokens_fmt} tokens"
            ;;
        status)
            local status msg
            status=$(echo "$line" | jq -r '.status // ""')
            msg=$(echo "$line" | jq -r '.msg // ""')
            local status_color
            case "$status" in
                RUNNING)  status_color="${GREEN}" ;;
                COMPLETE) status_color="${GREEN}" ;;
                ERROR)    status_color="${RED}" ;;
                STOPPED)  status_color="${DIM}" ;;
                *)        status_color="${NC}" ;;
            esac
            if [[ -n "$msg" ]]; then
                echo -e "${DIM}${time_fmt}${NC} ${CYAN}${project}/${ws}${NC} ${status_color}${status}${NC}: $msg"
            else
                echo -e "${DIM}${time_fmt}${NC} ${CYAN}${project}/${ws}${NC} ${status_color}${status}${NC}"
            fi
            ;;
        needs_input)
            local question
            question=$(echo "$line" | jq -r '.question // ""')
            echo -e "${DIM}${time_fmt}${NC} ${CYAN}${project}/${ws}${NC} ${YELLOW}⚠ NEEDS_INPUT${NC}: ${question:0:60}"
            ;;
        progress)
            local msg
            msg=$(echo "$line" | jq -r '.msg // ""')
            echo -e "${DIM}${time_fmt}${NC} ${CYAN}${project}/${ws}${NC} ${DIM}→${NC} $msg"
            ;;
        complete)
            local status
            status=$(echo "$line" | jq -r '.status // "COMPLETE"')
            echo -e "${DIM}${time_fmt}${NC} ${CYAN}${project}/${ws}${NC} ${GREEN}★ ${status}${NC}"
            ;;
        *)
            echo -e "${DIM}${time_fmt}${NC} ${CYAN}${project}/${ws}${NC} $event"
            ;;
    esac
}

# Watch command - live stream of workstream events
cmd_watch() {
    local filter_project=""
    local json_mode=false
    local follow=true
    local args_done=false

    # Parse flags
    for arg in "$@"; do
        case "$arg" in
            --json)
                json_mode=true
                ;;
            --no-follow|-n)
                follow=false
                ;;
            -*)
                # Unknown flag, skip
                ;;
            *)
                if [[ -z "$filter_project" ]]; then
                    filter_project="$arg"
                fi
                ;;
        esac
    done

    # Ensure events directory exists
    mkdir -p "$EVENTS_DIR"

    # JSON mode - just stream events
    if $json_mode; then
        if $follow; then
            if [[ -f "$EVENTS_FILE" ]]; then
                tail -f "$EVENTS_FILE" | while read -r line; do
                    if [[ -n "$filter_project" ]]; then
                        local proj
                        proj=$(echo "$line" | jq -r '.project // ""' 2>/dev/null)
                        [[ "$proj" != "$filter_project" ]] && continue
                    fi
                    echo "$line"
                done
            else
                echo "No events file found. Start a workstream first."
                return 1
            fi
        else
            if [[ -f "$EVENTS_FILE" ]]; then
                while read -r line; do
                    if [[ -n "$filter_project" ]]; then
                        local proj
                        proj=$(echo "$line" | jq -r '.project // ""' 2>/dev/null)
                        [[ "$proj" != "$filter_project" ]] && continue
                    fi
                    echo "$line"
                done < "$EVENTS_FILE"
            fi
        fi
        return 0
    fi

    # Human-readable mode
    echo -e "${BOLD}Ralph Watch${NC} - Live Progress"
    if [[ -n "$filter_project" ]]; then
        echo -e "${DIM}Filtering to project: $filter_project${NC}"
    fi
    if $follow; then
        echo -e "${DIM}Press Ctrl+C to exit${NC}"
    fi
    echo ""

    if ! $follow; then
        # One-shot mode: show recent events
        if [[ -f "$EVENTS_FILE" ]]; then
            local count=0
            while read -r line; do
                if [[ -n "$filter_project" ]]; then
                    local proj
                    proj=$(echo "$line" | jq -r '.project // ""' 2>/dev/null)
                    [[ "$proj" != "$filter_project" ]] && continue
                fi
                format_event "$line"
                count=$((count + 1))
            done < "$EVENTS_FILE"

            if [[ $count -eq 0 ]]; then
                echo "No events found."
            fi
        else
            echo "No events yet. Start a workstream to see progress."
        fi
        return 0
    fi

    # Follow mode: show existing events then tail
    if [[ ! -f "$EVENTS_FILE" ]]; then
        echo "No events yet. Waiting for workstream activity..."
        touch "$EVENTS_FILE"
    else
        # Show last 20 events to provide context
        local recent_events
        recent_events=$(tail -20 "$EVENTS_FILE")
        if [[ -n "$recent_events" ]]; then
            echo -e "${DIM}── Recent activity ──${NC}"
            while read -r line; do
                if [[ -n "$filter_project" ]]; then
                    local proj
                    proj=$(echo "$line" | jq -r '.project // ""' 2>/dev/null)
                    [[ "$proj" != "$filter_project" ]] && continue
                fi
                format_event "$line"
            done <<< "$recent_events"
            echo -e "${DIM}── Live feed ──${NC}"
            echo ""
        fi
    fi

    # Now tail for new events
    tail -f "$EVENTS_FILE" 2>/dev/null | while read -r line; do
        if [[ -n "$filter_project" ]]; then
            local proj
            proj=$(echo "$line" | jq -r '.project // ""' 2>/dev/null)
            [[ "$proj" != "$filter_project" ]] && continue
        fi
        format_event "$line"
    done
}

#═══════════════════════════════════════════════════════════════
# Workflow Dependencies & Orchestration (ralph run)
#═══════════════════════════════════════════════════════════════

WORKFLOWS_DIR="$RALPH_HOME/workflows"

# Parse a YAML workflow file and extract workstream definitions
# Returns JSON array of workstreams with name, prompt, iterations, depends_on
parse_workflow() {
    local workflow_file="$1"

    if [[ ! -f "$workflow_file" ]]; then
        error "Workflow file not found: $workflow_file"
        return 1
    fi

    # Use yq if available, otherwise fall back to simple parsing
    if command -v yq &>/dev/null; then
        yq -o=json "$workflow_file"
    else
        # Simple YAML parser for workflow format (limited but functional)
        local name="" prompt="" iterations=20 depends_on="[]"
        local in_workstreams=false
        local workstreams_json="["
        local first=true

        while IFS= read -r line || [[ -n "$line" ]]; do
            # Skip comments and empty lines
            [[ "$line" =~ ^[[:space:]]*# ]] && continue
            [[ -z "${line// /}" ]] && continue

            if [[ "$line" =~ ^workstreams: ]]; then
                in_workstreams=true
                continue
            fi

            if $in_workstreams; then
                # New workstream entry
                if [[ "$line" =~ ^[[:space:]]*-[[:space:]]*name:[[:space:]]*(.+) ]]; then
                    # Save previous workstream if exists
                    if [[ -n "$name" ]]; then
                        $first || workstreams_json+=","
                        first=false
                        workstreams_json+=$(printf '{"name":"%s","prompt":"%s","iterations":%d,"depends_on":%s}' \
                            "$name" "${prompt//\"/\\\"}" "$iterations" "$depends_on")
                    fi
                    name="${BASH_REMATCH[1]}"
                    prompt=""
                    iterations=20
                    depends_on="[]"
                elif [[ "$line" =~ ^[[:space:]]+prompt:[[:space:]]*[\"\']*(.+)[\"\']*$ ]]; then
                    prompt="${BASH_REMATCH[1]}"
                    prompt="${prompt%\"}"
                    prompt="${prompt%\'}"
                elif [[ "$line" =~ ^[[:space:]]+iterations:[[:space:]]*([0-9]+) ]]; then
                    iterations="${BASH_REMATCH[1]}"
                elif [[ "$line" =~ ^[[:space:]]+depends_on:[[:space:]]*\[(.+)\] ]]; then
                    # Parse array like [auth, database]
                    local deps="${BASH_REMATCH[1]}"
                    deps_json="["
                    local deps_first=true
                    for dep in $(echo "$deps" | tr ',' ' '); do
                        dep=$(echo "$dep" | tr -d ' "'"'"'')
                        [[ -z "$dep" ]] && continue
                        $deps_first || deps_json+=","
                        deps_first=false
                        deps_json+="\"$dep\""
                    done
                    deps_json+="]"
                    depends_on="$deps_json"
                fi
            fi
        done < "$workflow_file"

        # Save last workstream
        if [[ -n "$name" ]]; then
            $first || workstreams_json+=","
            workstreams_json+=$(printf '{"name":"%s","prompt":"%s","iterations":%d,"depends_on":%s}' \
                "$name" "${prompt//\"/\\\"}" "$iterations" "$depends_on")
        fi

        workstreams_json+="]"
        echo "{\"workstreams\":$workstreams_json}"
    fi
}

# Detect cycles in the dependency graph
# Returns 0 if no cycles, 1 if cycles detected
detect_cycles() {
    local workflow_json="$1"
    local workstreams
    workstreams=$(echo "$workflow_json" | jq -r '.workstreams[]?.name // empty' 2>/dev/null)

    # Build adjacency list and check for cycles using DFS
    local -a visiting=()
    local -a visited=()

    for ws in $workstreams; do
        local deps
        deps=$(echo "$workflow_json" | jq -r ".workstreams[] | select(.name==\"$ws\") | .depends_on[]? // empty" 2>/dev/null)
        for dep in $deps; do
            # Check if dependency exists
            if ! echo "$workstreams" | grep -q "^${dep}$"; then
                error "Unknown dependency '$dep' in workstream '$ws'"
                return 1
            fi
        done
    done

    # Simple cycle detection: check if any workstream depends on itself transitively
    for ws in $workstreams; do
        if has_cycle "$workflow_json" "$ws" "$ws" ""; then
            error "Cycle detected involving workstream '$ws'"
            return 1
        fi
    done

    return 0
}

# Check for cycles starting from a workstream
has_cycle() {
    local workflow_json="$1"
    local start="$2"
    local current="$3"
    local path="$4"

    # Prevent infinite recursion
    if [[ "${#path}" -gt 1000 ]]; then
        return 1
    fi

    local deps
    deps=$(echo "$workflow_json" | jq -r ".workstreams[] | select(.name==\"$current\") | .depends_on[]? // empty" 2>/dev/null)

    for dep in $deps; do
        if [[ "$dep" == "$start" ]] && [[ -n "$path" ]]; then
            return 0  # Cycle found
        fi
        if has_cycle "$workflow_json" "$start" "$dep" "${path}>${dep}"; then
            return 0
        fi
    done

    return 1
}

# Get workstreams with no dependencies (can start immediately)
get_ready_workstreams() {
    local workflow_json="$1"
    local completed="$2"  # Space-separated list of completed workstreams

    echo "$workflow_json" | jq -r --arg completed "$completed" '
        .workstreams[] |
        select(
            (.depends_on | length == 0) or
            (.depends_on | all(. as $dep | ($completed | split(" ") | index($dep))))
        ) |
        .name
    ' 2>/dev/null
}

# List available workflows
cmd_workflows() {
    echo ""
    echo -e "${BOLD}Available Workflows${NC}"
    echo ""

    mkdir -p "$WORKFLOWS_DIR"

    local found=false
    for workflow_file in "$WORKFLOWS_DIR"/*.yaml "$WORKFLOWS_DIR"/*.yml; do
        [[ -f "$workflow_file" ]] || continue
        found=true

        local name
        name=$(basename "$workflow_file" | sed 's/\.\(yaml\|yml\)$//')

        # Try to get workflow name from file
        local workflow_name
        workflow_name=$(grep "^name:" "$workflow_file" 2>/dev/null | head -1 | cut -d: -f2 | tr -d ' "'"'"'')
        [[ -z "$workflow_name" ]] && workflow_name="$name"

        # Count workstreams
        local ws_count
        ws_count=$(grep -c "^[[:space:]]*-[[:space:]]*name:" "$workflow_file" 2>/dev/null || echo "0")

        echo -e "  ${CYAN}$name${NC} - $workflow_name (${ws_count} workstreams)"
    done

    if ! $found; then
        echo "  No workflows defined yet."
        echo ""
        echo "  Create one at: $WORKFLOWS_DIR/<name>.yaml"
        echo ""
        echo "  Example workflow:"
        echo "    name: my-feature"
        echo "    workstreams:"
        echo "      - name: auth"
        echo "        prompt: \"Implement user authentication\""
        echo "        iterations: 15"
        echo "      - name: api"
        echo "        prompt: \"Create API endpoints\""
        echo "        iterations: 20"
        echo "        depends_on: [auth]"
    fi
    echo ""
}

# Run a workflow with dependency resolution
cmd_run_workflow() {
    local workflow_arg="$1"
    local dry_run=false

    # Parse flags
    shift || true
    for arg in "$@"; do
        case "$arg" in
            --dry-run|-n)
                dry_run=true
                ;;
        esac
    done

    if [[ -z "$workflow_arg" ]]; then
        error "Usage: ralph run <workflow.yaml> [--dry-run]"
        return 1
    fi

    # Resolve workflow file - try multiple locations
    local workflow_file=""
    local tried_paths=()

    # Try as-is
    tried_paths+=("$workflow_arg")
    if [[ -f "$workflow_arg" ]]; then
        workflow_file="$workflow_arg"
    fi

    # Try with .yaml extension
    if [[ -z "$workflow_file" ]]; then
        tried_paths+=("${workflow_arg}.yaml")
        if [[ -f "${workflow_arg}.yaml" ]]; then
            workflow_file="${workflow_arg}.yaml"
        fi
    fi

    # Try in workflows directory
    if [[ -z "$workflow_file" ]]; then
        tried_paths+=("$WORKFLOWS_DIR/$workflow_arg")
        if [[ -f "$WORKFLOWS_DIR/$workflow_arg" ]]; then
            workflow_file="$WORKFLOWS_DIR/$workflow_arg"
        fi
    fi

    # Try in workflows directory with .yaml extension
    if [[ -z "$workflow_file" ]]; then
        tried_paths+=("${WORKFLOWS_DIR}/${workflow_arg}.yaml")
        if [[ -f "${WORKFLOWS_DIR}/${workflow_arg}.yaml" ]]; then
            workflow_file="${WORKFLOWS_DIR}/${workflow_arg}.yaml"
        fi
    fi

    # Try in workflows directory with .yml extension
    if [[ -z "$workflow_file" ]]; then
        tried_paths+=("${WORKFLOWS_DIR}/${workflow_arg}.yml")
        if [[ -f "${WORKFLOWS_DIR}/${workflow_arg}.yml" ]]; then
            workflow_file="${WORKFLOWS_DIR}/${workflow_arg}.yml"
        fi
    fi

    if [[ -z "$workflow_file" ]]; then
        error "Workflow not found: $workflow_arg"
        echo "  Tried:"
        for path in "${tried_paths[@]}"; do
            echo "    - $path"
        done
        return 1
    fi

    # Parse workflow
    local workflow_json
    workflow_json=$(parse_workflow "$workflow_file")
    if [[ -z "$workflow_json" ]]; then
        error "Failed to parse workflow"
        return 1
    fi

    # Get workflow name
    local workflow_name
    workflow_name=$(echo "$workflow_json" | jq -r '.name // "workflow"' 2>/dev/null)

    # Check for cycles
    if ! detect_cycles "$workflow_json"; then
        return 1
    fi

    # Get workstream list
    local all_workstreams
    all_workstreams=$(echo "$workflow_json" | jq -r '.workstreams[].name' 2>/dev/null)
    local ws_count
    ws_count=$(echo "$all_workstreams" | wc -l | tr -d ' ')

    echo ""
    echo -e "${BOLD}Workflow: ${CYAN}$workflow_name${NC}"
    echo "──────────────────────────────────────────"
    echo ""

    # Show execution plan
    echo -e "${CYAN}Execution Plan:${NC}"

    # Group workstreams by dependency level
    local level=0
    local remaining="$all_workstreams"
    local completed=""

    while [[ -n "$remaining" ]]; do
        local ready
        ready=$(get_ready_workstreams "$workflow_json" "$completed")
        ready=$(echo "$ready" | grep -v '^$' || true)

        if [[ -z "$ready" ]]; then
            break
        fi

        echo ""
        if [[ $level -eq 0 ]]; then
            echo -e "  ${GREEN}▶ Start immediately (parallel):${NC}"
        else
            echo -e "  ${YELLOW}▶ After level $((level)) completes:${NC}"
        fi

        for ws in $ready; do
            # Skip if not in remaining
            echo "$remaining" | grep -q "^${ws}$" || continue

            local iterations prompt deps
            iterations=$(echo "$workflow_json" | jq -r ".workstreams[] | select(.name==\"$ws\") | .iterations" 2>/dev/null)
            prompt=$(echo "$workflow_json" | jq -r ".workstreams[] | select(.name==\"$ws\") | .prompt" 2>/dev/null)
            deps=$(echo "$workflow_json" | jq -r ".workstreams[] | select(.name==\"$ws\") | .depends_on | join(\", \")" 2>/dev/null)

            echo -e "    ${BOLD}$ws${NC} (${iterations} iterations)"
            if [[ -n "$deps" ]] && [[ "$deps" != "null" ]]; then
                echo -e "      ${DIM}depends on: $deps${NC}"
            fi
            echo -e "      ${DIM}\"${prompt:0:50}...\"${NC}"

            # Mark as "completed" for next round
            completed="$completed $ws"

            # Remove from remaining
            remaining=$(echo "$remaining" | grep -v "^${ws}$")
        done

        level=$((level + 1))

        # Safety check
        [[ $level -gt 50 ]] && break
    done

    echo ""

    if $dry_run; then
        echo -e "${DIM}Dry run - no workstreams started${NC}"
        return 0
    fi

    # Get project (must be specified or detected)
    local project="${PROJECT:-$(detect_project)}"
    if [[ -z "$project" ]]; then
        error "No project specified. Use -p <project> or run from a project directory."
        return 1
    fi

    if ! project_exists "$project"; then
        error "Project not found: $project"
        return 1
    fi

    echo -e "${BOLD}Starting workflow execution...${NC}"
    echo ""

    # Track running and completed workstreams
    local running=""
    local completed=""
    local failed=""

    # Start workstreams with no dependencies
    local ready
    ready=$(get_ready_workstreams "$workflow_json" "$completed")

    for ws in $ready; do
        local iterations prompt
        iterations=$(echo "$workflow_json" | jq -r ".workstreams[] | select(.name==\"$ws\") | .iterations" 2>/dev/null)
        prompt=$(echo "$workflow_json" | jq -r ".workstreams[] | select(.name==\"$ws\") | .prompt" 2>/dev/null)

        echo -e "${GREEN}▶${NC} Starting ${CYAN}$ws${NC}..."

        # Create PROMPT.md for this workstream
        local ws_dir="$RALPH_HOME/workstreams/$project/$ws"
        mkdir -p "$ws_dir"
        echo "$prompt" > "$ws_dir/PROMPT.md"

        # Start the workstream
        cmd_start "$project" "$ws" "$iterations"
        running="$running $ws"
    done

    # Monitor and start dependent workstreams as deps complete
    echo ""
    echo -e "${DIM}Monitoring workstream progress...${NC}"
    echo -e "${DIM}Use 'ralph watch' in another terminal for live progress${NC}"
    echo ""

    local all_done=false
    local check_count=0
    local max_checks=3600  # 1 hour at 1 check/sec

    while ! $all_done && [[ $check_count -lt $max_checks ]]; do
        sleep 2
        check_count=$((check_count + 1))

        # Check status of running workstreams
        local still_running=""
        for ws in $running; do
            ws=$(echo "$ws" | tr -d ' ')
            [[ -z "$ws" ]] && continue

            local status
            status=$(get_status "$project" "$ws")

            case "$status" in
                COMPLETE|MERGED)
                    completed="$completed $ws"
                    echo -e "${GREEN}✓${NC} ${CYAN}$ws${NC} completed"

                    # Check if any new workstreams can start
                    local newly_ready
                    newly_ready=$(get_ready_workstreams "$workflow_json" "$completed")

                    for new_ws in $newly_ready; do
                        # Skip if already started
                        echo "$completed $running" | grep -q "$new_ws" && continue

                        local iterations prompt
                        iterations=$(echo "$workflow_json" | jq -r ".workstreams[] | select(.name==\"$new_ws\") | .iterations" 2>/dev/null)
                        prompt=$(echo "$workflow_json" | jq -r ".workstreams[] | select(.name==\"$new_ws\") | .prompt" 2>/dev/null)

                        echo -e "${GREEN}▶${NC} Starting ${CYAN}$new_ws${NC} (deps satisfied)..."

                        local ws_dir="$RALPH_HOME/workstreams/$project/$new_ws"
                        mkdir -p "$ws_dir"
                        echo "$prompt" > "$ws_dir/PROMPT.md"

                        cmd_start "$project" "$new_ws" "$iterations"
                        still_running="$still_running $new_ws"
                    done
                    ;;
                ERROR|STUCK)
                    failed="$failed $ws"
                    echo -e "${RED}✗${NC} ${CYAN}$ws${NC} failed (status: $status)"
                    ;;
                NEEDS_INPUT)
                    still_running="$still_running $ws"
                    echo -e "${YELLOW}⚠${NC} ${CYAN}$ws${NC} needs input - use 'ralph -p $project answer $ws'"
                    ;;
                RUNNING|*)
                    still_running="$still_running $ws"
                    ;;
            esac
        done

        running="$still_running"

        # Check if all done
        local completed_count
        completed_count=$(echo "$completed" | wc -w | tr -d ' ')

        if [[ $completed_count -ge $ws_count ]]; then
            all_done=true
        fi

        # No more running and not all done = some failed or stuck
        if [[ -z "$(echo "$running" | tr -d ' ')" ]] && ! $all_done; then
            echo -e "${YELLOW}Warning: No running workstreams but workflow not complete${NC}"
            break
        fi
    done

    echo ""
    echo "──────────────────────────────────────────"
    echo -e "${BOLD}Workflow Summary${NC}"
    echo ""
    local completed_count failed_count
    completed_count=$(echo "$completed" | wc -w | tr -d ' ')
    failed_count=$(echo "$failed" | wc -w | tr -d ' ')

    echo -e "  Completed: ${GREEN}$completed_count${NC}/$ws_count"
    if [[ $failed_count -gt 0 ]]; then
        echo -e "  Failed: ${RED}$failed_count${NC}"
    fi
    echo ""

    if [[ $completed_count -eq $ws_count ]]; then
        echo -e "${GREEN}✓ Workflow completed successfully!${NC}"
    else
        echo -e "${YELLOW}⚠ Workflow did not complete. Check workstream status with 'ralph status'${NC}"
    fi
}

#═══════════════════════════════════════════════════════════════
# Interactive Dashboard
#═══════════════════════════════════════════════════════════════

interactive_mode_global() {
    echo ""
    echo -e "${BOLD}Ralph - Global Dashboard${NC}"
    echo ""

    # Collect all workstreams across all projects
    local has_active=false
    local all_rows=()

    for project_file in "$RALPH_HOME/projects/"*.yaml; do
        [[ -f "$project_file" ]] || continue

        local project
        project=$(basename "$project_file" .yaml)
        local workstreams_str
        workstreams_str=$(get_workstreams "$project")

        if [[ -n "$workstreams_str" ]]; then
            for ws in $workstreams_str; do
                has_active=true
                all_rows+=("$project|$ws")
            done
        fi
    done

    if ! $has_active; then
        echo "No active workstreams"
        echo ""
        echo "Start one with: ralph -p <project> start <workstream>"
        return
    fi

    # Table header
    printf "┌─────────────────┬─────────────────┬──────────┬────────────┬──────────┬─────────┬──────────┐\n"
    printf "│ %-15s │ %-15s │ %-8s │ %-10s │ %-8s │ %-7s │ %-8s │\n" \
           "Project" "Workstream" "Status" "Progress" "Tokens" "Cost" "Duration"
    printf "├─────────────────┼─────────────────┼──────────┼────────────┼──────────┼─────────┼──────────┤\n"

    for row in "${all_rows[@]}"; do
        local project ws
        project=$(echo "$row" | cut -d'|' -f1)
        ws=$(echo "$row" | cut -d'|' -f2)

        local status iteration metrics
        status=$(get_status "$project" "$ws")
        iteration=$(get_iteration "$project" "$ws")
        metrics=$(get_metrics "$project" "$ws")

        local max_iter tokens_in tokens_out total_tokens cost start_time end_time
        max_iter=$(echo "$metrics" | jq -r '.max_iterations // 100')
        tokens_in=$(echo "$metrics" | jq -r '.tokens_in // 0')
        tokens_out=$(echo "$metrics" | jq -r '.tokens_out // 0')
        total_tokens=$((tokens_in + tokens_out))
        cost=$(echo "$metrics" | jq -r '.total_cost // 0')
        start_time=$(echo "$metrics" | jq -r '.start_time // ""')
        end_time=$(echo "$metrics" | jq -r '.end_time // ""')

        local progress_pct=0
        [[ $max_iter -gt 0 ]] && progress_pct=$((iteration * 100 / max_iter))

        local tokens_fmt cost_fmt duration_fmt progress_fmt
        tokens_fmt=$(format_tokens "$total_tokens")
        cost_fmt=$(printf "\$%.2f" "$cost")

        # Use end_time for stopped/complete workstreams, now for running
        if [[ "$status" == "RUNNING" ]] || [[ -z "$end_time" ]] || [[ "$end_time" == "null" ]]; then
            duration_fmt=$(format_duration "$start_time")
        else
            duration_fmt=$(format_duration_between "$start_time" "$end_time")
        fi

        # Progress display: DONE for complete, percentage otherwise
        if [[ "$status" == "COMPLETE" ]]; then
            progress_fmt="  DONE    "
        else
            progress_fmt=$(printf "%2d/%-3d %2d%%" "$iteration" "$max_iter" "$progress_pct")
        fi

        # Truncate names to 15 chars
        local proj_short="${project:0:15}"
        local ws_short="${ws:0:15}"

        # Status with color
        local status_display
        case "$status" in
            RUNNING)     status_display="${GREEN}RUNNING${NC}" ;;
            COMPLETE)    status_display="${GREEN}COMPLETE${NC}" ;;
            STOPPED)     status_display="${DIM}STOPPED${NC}" ;;
            NEEDS_INPUT) status_display="${YELLOW}NEEDS_IN${NC}" ;;
            STUCK)       status_display="${RED}STUCK${NC}" ;;
            ERROR)       status_display="${RED}ERROR${NC}" ;;
            *)           status_display="$status" ;;
        esac

        echo -e "│ $(printf '%-15s' "$proj_short") │ $(printf '%-15s' "$ws_short") │ ${status_display}$(printf '%*s' $((8 - ${#status})) '') │ $(printf '%-10s' "$progress_fmt") │ $(printf '%-8s' "$tokens_fmt") │ $(printf '%-7s' "$cost_fmt") │ $(printf '%-8s' "$duration_fmt") │"
    done

    printf "└─────────────────┴─────────────────┴──────────┴────────────┴──────────┴─────────┴──────────┘\n"
    echo ""
}

interactive_mode() {
    local project="$1"

    if [[ -z "$project" ]]; then
        interactive_mode_global
        return
    fi

    if ! project_exists "$project"; then
        error "Project not found: $project"
        return 1
    fi

    while true; do
        clear
        echo -e "${BOLD}Ralph - ${project}${NC}"
        echo "========================"
        echo ""

        local workstreams
        workstreams=($(get_workstreams "$project"))
        local has_questions=false
        local question_ws=""

        for ws in "${workstreams[@]}"; do
            local status iter icon question
            status=$(get_status "$project" "$ws")
            iter=$(get_iteration "$project" "$ws")
            icon=$(status_icon "$status")
            question=$(get_question "$project" "$ws")

            echo -e "  ${icon} ${BOLD}${ws}${NC} - ${status} (iter ${iter})"
            if [[ -n "$question" ]]; then
                echo -e "     ${YELLOW}Q: ${question:0:50}...${NC}"
                has_questions=true
                question_ws="$ws"
            fi
        done

        if [[ ${#workstreams[@]} -eq 0 ]]; then
            echo "  No active workstreams"
        fi

        echo ""
        echo -e "${BOLD}Actions:${NC}"
        local menu_num=1

        if $has_questions; then
            echo -e "  ${CYAN}${menu_num}.${NC} Answer question for ${YELLOW}${question_ws}${NC}"
            ((menu_num++))
        fi

        echo -e "  ${CYAN}${menu_num}.${NC} Start new workstream"
        ((menu_num++))
        echo -e "  ${CYAN}${menu_num}.${NC} Attach to workstream"
        ((menu_num++))
        echo -e "  ${CYAN}${menu_num}.${NC} Stop workstream"
        ((menu_num++))
        echo -e "  ${CYAN}${menu_num}.${NC} Cleanup workstream"
        ((menu_num++))
        echo -e "  ${DIM}q. Quit${NC}"
        echo ""

        read -r -p "> " choice

        case $choice in
            q|Q) exit 0 ;;
            1)
                if $has_questions; then
                    cmd_answer "$project" "$question_ws"
                else
                    echo ""
                    read -r -p "Workstream name: " name
                    read -r -p "Max iterations (20): " max_iter
                    cmd_start "$project" "$name" "${max_iter:-20}"
                fi
                ;;
            2)
                if $has_questions; then
                    echo ""
                    read -r -p "Workstream name: " name
                    read -r -p "Max iterations (20): " max_iter
                    cmd_start "$project" "$name" "${max_iter:-20}"
                else
                    if [[ ${#workstreams[@]} -gt 0 ]]; then
                        echo ""
                        echo "Select workstream:"
                        select ws in "${workstreams[@]}"; do
                            [[ -n "$ws" ]] && cmd_attach "$project" "$ws"
                            break
                        done
                    fi
                fi
                ;;
            3)
                if $has_questions; then
                    if [[ ${#workstreams[@]} -gt 0 ]]; then
                        echo ""
                        echo "Select workstream:"
                        select ws in "${workstreams[@]}"; do
                            [[ -n "$ws" ]] && cmd_attach "$project" "$ws"
                            break
                        done
                    fi
                else
                    if [[ ${#workstreams[@]} -gt 0 ]]; then
                        echo ""
                        echo "Select workstream:"
                        select ws in "${workstreams[@]}" "Stop all"; do
                            if [[ "$ws" == "Stop all" ]]; then
                                cmd_stop "$project" "--all"
                            elif [[ -n "$ws" ]]; then
                                cmd_stop "$project" "$ws"
                            fi
                            break
                        done
                    fi
                fi
                ;;
            4)
                if $has_questions; then
                    if [[ ${#workstreams[@]} -gt 0 ]]; then
                        echo ""
                        echo "Select workstream:"
                        select ws in "${workstreams[@]}" "Stop all"; do
                            if [[ "$ws" == "Stop all" ]]; then
                                cmd_stop "$project" "--all"
                            elif [[ -n "$ws" ]]; then
                                cmd_stop "$project" "$ws"
                            fi
                            break
                        done
                    fi
                else
                    if [[ ${#workstreams[@]} -gt 0 ]]; then
                        echo ""
                        echo "Select workstream:"
                        select ws in "${workstreams[@]}"; do
                            [[ -n "$ws" ]] && cmd_cleanup "$project" "$ws"
                            break
                        done
                    fi
                fi
                ;;
            5)
                if [[ ${#workstreams[@]} -gt 0 ]]; then
                    echo ""
                    echo "Select workstream:"
                    select ws in "${workstreams[@]}"; do
                        [[ -n "$ws" ]] && cmd_cleanup "$project" "$ws"
                        break
                    done
                fi
                ;;
        esac

        read -r -p "Press enter to continue..."
    done
}

#═══════════════════════════════════════════════════════════════
# Server Commands
#═══════════════════════════════════════════════════════════════

SERVER_DIR="$RALPH_HOME/server"
SERVER_PID_FILE="$RALPH_HOME/server.pid"

cmd_server_start() {
    if [[ -f "$SERVER_PID_FILE" ]]; then
        local pid
        pid=$(cat "$SERVER_PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            warn "Server already running (PID $pid)"
            return
        fi
    fi

    # Check if dependencies installed
    if [[ ! -d "$SERVER_DIR/node_modules" ]]; then
        echo -e "${CYAN}Installing server dependencies...${NC}"
        cd "$SERVER_DIR"
        npm install --silent
    fi

    local port
    port=$(grep "port:" "$RALPH_HOME/config.yaml" 2>/dev/null | head -1 | grep -o '[0-9]*' || echo "3847")

    echo -e "${CYAN}Starting Ralph API server on port $port...${NC}"
    cd "$SERVER_DIR"
    nohup node server.js > "$RALPH_HOME/logs/server.log" 2>&1 &
    echo $! > "$SERVER_PID_FILE"

    sleep 1
    if kill -0 "$(cat "$SERVER_PID_FILE")" 2>/dev/null; then
        echo -e "${GREEN}Server started!${NC}"
        echo "  PID: $(cat "$SERVER_PID_FILE")"
        echo "  URL: http://localhost:$port"
        echo "  Log: $RALPH_HOME/logs/server.log"
    else
        error "Failed to start server. Check $RALPH_HOME/logs/server.log"
        rm -f "$SERVER_PID_FILE"
    fi
}

cmd_server_stop() {
    if [[ ! -f "$SERVER_PID_FILE" ]]; then
        echo "Server not running"
        return
    fi

    local pid
    pid=$(cat "$SERVER_PID_FILE")
    if kill -0 "$pid" 2>/dev/null; then
        kill "$pid"
        echo -e "${GREEN}Server stopped${NC}"
    else
        echo "Server not running (stale PID file)"
    fi
    rm -f "$SERVER_PID_FILE"
}

cmd_server_status() {
    if [[ -f "$SERVER_PID_FILE" ]]; then
        local pid
        pid=$(cat "$SERVER_PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            local port
            port=$(grep "port:" "$RALPH_HOME/config.yaml" 2>/dev/null | head -1 | grep -o '[0-9]*' || echo "3847")
            echo -e "${GREEN}Server running${NC}"
            echo "  PID: $pid"
            echo "  URL: http://localhost:$port"
            return
        fi
    fi
    echo "Server not running"
}

cmd_server_key() {
    local key
    key=$(openssl rand -hex 24)

    # Update config file - handle both commented and uncommented api_key lines
    if grep -q "^[[:space:]]*api_key:" "$RALPH_HOME/config.yaml" 2>/dev/null; then
        # Update existing uncommented key
        sed -i '' "s/^[[:space:]]*api_key:.*/  api_key: \"$key\"/" "$RALPH_HOME/config.yaml"
    elif grep -q "#.*api_key:" "$RALPH_HOME/config.yaml" 2>/dev/null; then
        # Replace commented key with uncommented one
        sed -i '' "s/#.*api_key:.*/  api_key: \"$key\"/" "$RALPH_HOME/config.yaml"
    else
        # Add key to server section
        if grep -q "^server:" "$RALPH_HOME/config.yaml" 2>/dev/null; then
            sed -i '' "/^server:/a\\
  api_key: \"$key\"
" "$RALPH_HOME/config.yaml"
        else
            echo "" >> "$RALPH_HOME/config.yaml"
            echo "# API server authentication" >> "$RALPH_HOME/config.yaml"
            echo "server:" >> "$RALPH_HOME/config.yaml"
            echo "  api_key: \"$key\"" >> "$RALPH_HOME/config.yaml"
        fi
    fi

    echo -e "${GREEN}API key generated:${NC}"
    echo "  $key"
    echo ""
    echo "Use in requests:"
    echo "  curl -H 'X-API-Key: $key' http://localhost:3847/projects"
    echo ""
    echo "Restart server to apply: ralph server restart"
}

cmd_server_restart() {
    cmd_server_stop
    sleep 1
    cmd_server_start
}

cmd_server_help() {
    echo ""
    echo -e "${BOLD}ralph server${NC} - Manage REST API server"
    echo ""
    echo -e "${CYAN}Commands:${NC}"
    echo "  ralph server start     Start the API server"
    echo "  ralph server stop      Stop the API server"
    echo "  ralph server status    Check server status"
    echo "  ralph server restart   Restart the server"
    echo "  ralph server key       Generate new API key"
    echo ""
    echo -e "${CYAN}Endpoints:${NC}"
    echo "  GET  /projects                           List all projects"
    echo "  GET  /projects/:name                     Get project details"
    echo "  GET  /projects/:name/workstreams         List workstreams"
    echo "  GET  /projects/:name/workstreams/:ws     Get workstream status"
    echo "  POST /projects/:name/workstreams/:ws/stop   Stop workstream"
    echo "  POST /projects/:name/workstreams/:ws/answer Answer question"
    echo "  GET  /projects/:name/workstreams/:ws/logs   Get log tail"
    echo ""
}

#═══════════════════════════════════════════════════════════════
# Help
#═══════════════════════════════════════════════════════════════

cmd_help() {
    echo ""
    echo -e "${BOLD}ralph${NC} v${RALPH_VERSION} - Autonomous AI development orchestrator"
    echo ""
    echo -e "${CYAN}Quick View:${NC}"
    echo "  ralph                             Show status + diagnostics + notes"
    echo "  ralph status                      Same as above"
    echo "  ralph dashboard                   Interactive menu mode"
    echo ""
    echo -e "${CYAN}Project Management:${NC}"
    echo "  ralph projects                    List registered projects"
    echo "  ralph projects add                Register current directory"
    echo "  ralph projects add --multi-repo   Auto-detect repos in subdirectories"
    echo "  ralph projects remove <name>      Unregister a project"
    echo "  ralph projects update <name>      Re-detect repos"
    echo ""
    echo -e "${CYAN}Workstream Operations:${NC}"
    echo "  ralph -p <proj> start <ws> [n]    Start workstream (n iterations)"
    echo "  ralph -p <proj> stop <ws>         Stop workstream"
    echo "  ralph -p <proj> attach <ws>       Watch live (Ctrl-b d to detach)"
    echo "  ralph -p <proj> answer [ws]       Answer pending question"
    echo "  ralph -p <proj> cleanup <ws>      Merge and remove worktree"
    echo "  ralph -p <proj> logs <ws>         Tail log file"
    echo ""
    echo -e "${CYAN}Workstream Notes:${NC}"
    echo "  ralph -p <proj> note <ws> \"text\"  Add note to workstream"
    echo "  ralph -p <proj> note <ws>         Show note"
    echo "  ralph -p <proj> note <ws> --clear Clear note"
    echo "  ralph notes                       List all notes"
    echo ""
    echo -e "${CYAN}Live Progress:${NC}"
    echo "  ralph watch                       Live progress from all workstreams"
    echo "  ralph watch <project>             Filter to one project"
    echo "  ralph watch --json                Raw JSONL stream (for piping)"
    echo "  ralph watch -n                    One-shot mode (no follow)"
    echo ""
    echo -e "${CYAN}Workflows (DAG Orchestration):${NC}"
    echo "  ralph workflows                   List available workflows"
    echo "  ralph run <workflow>              Execute workflow with dependencies"
    echo "  ralph run <workflow> --dry-run    Show execution plan without running"
    echo ""
    echo -e "${CYAN}Maintenance:${NC}"
    echo "  ralph recover                     Find orphaned workstreams"
    echo "  ralph prune [--dry-run]           Remove stale workstream state"
    echo "  ralph history [--all] [project]   Show workstream history"
    echo ""
    echo -e "${CYAN}Server (REST API):${NC}"
    echo "  ralph server start                Start API server"
    echo "  ralph server stop                 Stop API server"
    echo "  ralph server status               Check server status"
    echo "  ralph server key                  Generate API key"
    echo "  ralph server help                 Show endpoints"
    echo ""
    echo -e "${CYAN}Configuration:${NC}"
    echo "  Config: ${RALPH_HOME}/config.yaml"
    echo "  Projects: ${RALPH_HOME}/projects/"
    echo "  Workstreams: ${RALPH_HOME}/workstreams/"
    echo ""
}

#═══════════════════════════════════════════════════════════════
# Main Entry Point
#═══════════════════════════════════════════════════════════════

# Ensure directories exist
mkdir -p "$RALPH_HOME"/{bin,projects,workstreams,logs,state}

# Parse arguments
PROJECT=""
COMMAND=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -p|--project)
            PROJECT="$2"
            shift 2
            ;;
        *)
            break
            ;;
    esac
done

COMMAND="${1:-}"
ARG1="${2:-}"
ARG2="${3:-}"

# Route commands
case $COMMAND in
    projects)
        case ${ARG1:-list} in
            list|"")  cmd_projects_list ;;
            add)      cmd_projects_add "${@:3}" ;;
            remove)   cmd_projects_remove "$ARG2" ;;
            update)   cmd_projects_update "$ARG2" ;;
            help)     cmd_projects_help ;;
            *)        cmd_projects_help ;;
        esac
        ;;
    start)
        PROJECT="${PROJECT:-$(detect_project)}"
        cmd_start "$PROJECT" "$ARG1" "$ARG2"
        ;;
    stop)
        PROJECT="${PROJECT:-$(detect_project)}"
        cmd_stop "$PROJECT" "$ARG1"
        ;;
    status)
        # Global status if no project specified, project status otherwise
        if [[ -z "$PROJECT" ]]; then
            cmd_status_global
        else
            cmd_status "$PROJECT"
        fi
        ;;
    attach)
        PROJECT="${PROJECT:-$(detect_project)}"
        cmd_attach "$PROJECT" "$ARG1"
        ;;
    answer)
        PROJECT="${PROJECT:-$(detect_project)}"
        cmd_answer "$PROJECT" "$ARG1"
        ;;
    cleanup)
        PROJECT="${PROJECT:-$(detect_project)}"
        cmd_cleanup "$PROJECT" "$ARG1"
        ;;
    logs)
        PROJECT="${PROJECT:-$(detect_project)}"
        cmd_logs "$PROJECT" "$ARG1"
        ;;
    note)
        PROJECT="${PROJECT:-$(detect_project)}"
        cmd_note "$PROJECT" "$ARG1" "${@:4}"
        ;;
    notes)
        cmd_notes "$PROJECT"
        ;;
    watch)
        cmd_watch "${@:2}"
        ;;
    run)
        cmd_run_workflow "$ARG1" "${@:3}"
        ;;
    workflows)
        cmd_workflows
        ;;
    dashboard|menu)
        if [[ -n "$PROJECT" ]]; then
            interactive_mode "$PROJECT"
        else
            interactive_mode_global
        fi
        ;;
    recover)
        cmd_recover
        ;;
    prune)
        cmd_prune "$ARG1"
        ;;
    history)
        cmd_history "${@:2}"
        ;;
    server)
        case ${ARG1:-help} in
            start)   cmd_server_start ;;
            stop)    cmd_server_stop ;;
            status)  cmd_server_status ;;
            restart) cmd_server_restart ;;
            key)     cmd_server_key ;;
            help|*)  cmd_server_help ;;
        esac
        ;;
    help|--help|-h)
        cmd_help
        ;;
    "")
        # Default: show global status (non-interactive)
        cmd_status_global
        ;;
    *)
        error "Unknown command: $COMMAND"
        cmd_help
        exit 1
        ;;
esac
